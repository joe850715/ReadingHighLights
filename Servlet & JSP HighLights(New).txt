---JSP / SERVLET READING HIGHLIGHTS---

CHAPTER01.簡介WEB應用程式

01.URL / URN / URI的區別
	用來告訴瀏覽器取得文件檔案等資源的路徑
	(1)URL(Uniform Resource Locator):最早出現的標準
	(2)URN(Uniform Resource Name):代表某個資源獨一無二的"名稱"，與URL相同用來識別資源用
	(3)URI(Uniform Resource Identifier):最晚出現，URL與URN成為了URI的子集
	範例參照書籍page 1-5
	
02.何為HTTP
	HTTP作為一種通訊協定，定義了兩台電腦間的溝通方式，也就是Client與Server端連線、交換資訊的確認步驟
	有兩個基本的重要特性：
		(1)基於請求與回應(Request/Response)
			-沒有請求就不會有回應
		(2)無狀態協定(Stateless)
			-Web網站回應完成後，就不會記得瀏覽器的資訊(Request的生命週期僅限執行一次)
		
		<P.S>與HTTPS的區別
			HTTP傳送的資料都是明文(未加密的)，有安全上的疑慮，因此網景公司設計了SSL（Secure Sockets Layer）
			用以對HTTP傳輸的數據加密，於是誕生HTTPS(=HTTP+SSL)，一個可進行加密傳輸與身分認證的通訊協定
			
		HTTPS和HTTP的區別主要如下：
		1、https協定需要到ca申請證書，一般免費證書較少，因而需要一定費用。
		2、HTTP是超文本傳輸協定，資訊是明文傳輸，HTTPs則是具有安全性的ssl加密傳輸協定。
		3、HTTP和HTTPs使用的是完全不同的連接方式，用的埠也不一樣，前者是80，後者是443。
		4、HTTP的連接是無狀態的;HTTPS協定是由SSL+HTTP協議構建的可進行加密傳輸、身份認證的網路協定，比HTTP協定安全

03.常用的GET/POST請求
	(1)GET:
		向Web網站請求取得指定資源，除了發送取得資源的URI、請求參數之外也會一併發送標頭(Header)資訊，
		請求參數放在路徑的query String中，因此網址列中會出現參數資訊
	
	(2)POST:
		處理大量的資訊發送，同樣也有發送請求參數與Header，
		不過請求參數的位置在Header之後的訊息本體(Body Message)中，
		由於訊息本體長度不受限，所以可以處理大量資料的發送
		同時網址列也不會出現參數資訊，適合傳送較敏感資訊
		
	<P.S>雖然請求參數不會出現在網址列，但仍有可能遭到第三方攻擊而被截取，因此HTTPS的加密連線還是必要的
	<P.P.S>請求標頭(Header)
		提供WEB網站一些瀏覽器相關的資訊，方便透過這些資訊進行回應處理。例如：
		User-Agent中得知使用者的瀏覽器種類與版本
		Accept-Language了解瀏覽器接受那些語系的內容回應
	
04.安全方法與等冪方法
	(1)安全方法(Safe methods):
		實做應用程式時，避免有使用者非預期中的結果，如GET/HEAD對使用者來說是用來"取得"資訊，
		因此不該被拿來"修改"資訊，例如轉帳或刪除帳號，也因此GET確實是安全方法，並不能說GET比較不安全
		所謂安全與否並非指方法對Server是否產生副作用(Side Effect)，而是對使用者來說是否安全
		
	(2)等冪方法(Idmpotent methods):
		單一次請求造成的副作用，與同樣請求進行多次的副作用必須是相同的
		EX.執行Delete把某筆資料刪除，隨後多次執行delete結果會是該筆資料不存在而非刪除更多筆
		其中只有POST不符合等冪特性，因為每次送出POST要求指定URI接受Body中的請求參數會有不同
		也因此每次POST的副作用也會不同

05.REST架構(REpresentational State Transfer)
	基於HTTP1.0/HTTP1.1平行發展但不限於HTTP的架構，
	與HTTP雷同，此架構由Client/Server端組成，且兩者間的通訊機制也是無狀態的(Stateless)
	而RESTful則是代表一種"設計風格"，泛指符合REST架構原則的系統，例如：
	POST/book 		用來新增一筆資料
	GET/book/1 		用來取得ID為1的書
	DELETE/book/1 	用來刪除ID為1的書...
	
06.URI百分比編碼(或URI編碼)
	(1)URI保留字元
		URI保留字元中，常用的有「:」、「/」、「?」、「&」、「=」、「@」、「%」等字元，
		於網址列表達時需要將代表該字元的8個位元以16進制表示並接在%之後，例如「:」-->00111010
		轉換為16進制後為3A	因此使用%3A表示
	(2)中文字元
		URI編碼針對的是UTF-8編碼的8位元數值，若請求參數都是ASCII字元時，由於UTF-8在ASCII部分有相容因此沒問題，
		非ASCII字元例如中文，UTF-8使用3個位元組來表示，如「林」就會轉為E6.9E.97--> %E6%9E%97
		<P.S>若編碼為MS950的情況下，林-->只有兩個位元組，會變成%AA%4C因此Web網站處理參數時就要指定MS950編碼
		
07.前端技術與後端技術
	粗略來說，交給瀏覽器去執行的技術屬於前端的範疇，而執行於Web網站的屬於後端技術。
	例如：JSP/Servlet屬於後端技術，執行於Web網站的記憶體空間；JS屬於前端技術，執行於使用者電腦上的記憶體空間(瀏覽器上)
	兩者的記憶體空間實體位置不同，無法直接互動，需要透過網路經由HTTP進行互動與資料交換達成應用程式功能

08.何謂WEB容器	
	作為JSP/Servlet唯一認得並可以用來運行JSP/Servlet的HTTP伺服器，他是由Java寫成並運行於JVM之上的程式，
	不只是用來持有、保存物件的群集(Collection)物件，同時也掌管物件的生命週期與相關服務連結
	HTTP那些文字性的通訊協定，就是透過容器居中進行剖析與轉換成Java物件。
	只要JSP/Servlet撰寫時符合WEB容器標準規範，就可以在任何廠商時做的WEB容器上運行，
	不用管底層真正的HTTP伺服器為何(參考書籍Page 1-19)
	如同JVM介於Java程式與實體作業系統之間，WEB容器介於實體HTTP Server與Server之間
	
09.	
	瀏覽器<------>實體伺服器<--->HTTP伺服器程式<--->WEB容器<--->Servlet
	
	-瀏覽器的請求由HTTP伺服器轉給WEB容器，WEB容器剖析HTTP請求內容並建立各種物件(HttpSession,HttpServletRequest,...)
	-WEB容器根據URI決定使用哪個Servlet處理請求
	-Servlet根據HttpServletRequest決定如何處理並透過HttpServletResponse建立回應
	-WEB容器與HTTP伺服器溝通，HTTP伺服器將回硬物件轉為HTTP回應回傳給瀏覽器
	-JVM本身是伺服器上的一個可執行程式，WEB容器由這個JVM去啟動，Servlet又是執行在WEB容器之中
	-當有請求進來時，WEB容器會幫每個請求分配一個Thread
	-有多個請求時就有多個執行緒而非多次開關JVM
	
10.	WEB容器可以使用同一個Servlet處理多個請求，因此需要注意執行緒安全的問題避免資料錯亂

11.Servlet
	Servlet類別必須繼承HttpServlet，並且如果要輸出HTML的話需要透過Java的輸入輸出功能，
	如從HttpServletResponse取得的PrintWriter。
	不過Servlet主要用於定義Java程式邏輯，應避免用來輸出網頁內容，
	如需輸出網頁內容應該要選擇使用JSP
	
--------------------------------------------------------------------------------------------

CHAPTER02.撰寫與設定Servlet

01.關於HttpServlet
	要編譯Hello.java，類別路徑(ClassPath)中必須包含ServletAPI的相關類別
	若使用的是Tomcat，這些相關類別會封裝在Tomcat/lib中的servlet-api.jar當中。
	編譯出的.class檔則會出現在專案/build/classes資料夾中
	
02.Servlet介面的繼承與實作(簡易描述)
	Servlet介面中定義了Servlet的基本行為：init(),destroy(),service()等等
	包含管理生命週期與提供服務時需要呼叫的方法。
	Servlet定義相關的類別與介面都未於javax.servlet套件中
	與HTTP相關的類別或介面都位於javax.servlet.http套件中
	
	其中，HttpServlet類別繼承實作了Servlet介面的GenericServlet類別，並定義了GenericServlet中的抽象方法service()
	當接收到請求時，容器會呼叫service()方法，用來判斷HTTP請求的方式後再分別呼叫doGet,doPost
	<P.S>不要覆寫到service()方法，這會把HttpServlet中定義的HTTP預設處理流程給覆蓋

03.	@WebServlet標註
	使用@WebServlet Annotation可以讓容器自動讀取當中的資訊，
	除了URI路徑之外，也可提供更多資訊如:name(Servlet的名稱),loadOnStartUp的次序
	<P.S>
		當沒有設定Servlet name 的時候其預設值會是Servlet類別的完整名稱
		應用程式啟動後預設不會建立任何Servlet實體，除非有loadOnStartUp設定(預設值-1,必須設定一個>0的值，越小越優先)
		
04.部屬描述檔(Deployment Descriptor,DD)
	即是專案中的web.xml檔案，可用於定義Servlet的相關資訊，
	在Servlet3.0之前尚未有Annotation可以使用時都部屬描述檔定義Servlet資訊
	
05.環境根目錄(Context Root)
	<display-name>標籤中定義了"Web APP的名稱"，這僅是一個名稱並非等同於WebAPP的根目錄
	Servlet4.0以前並沒有規範如何定義WebAPP環境根目錄，因此各廠商有各自定義方式
	例如：Tomcat可以在META-INF/context.xml中設定環境根目錄，正常情況下預設應用程式資料夾作為環境根目錄
	使用Eclipse的話也可在專案右鍵/Properties/WebProjectSettings裡面去設定環境根目錄
	Servlet4.0開始可以在web.xml中使用<default-context-path>來建議預設環境路徑
	
06.<welcome-file-list>	
	作為請求的路徑沒有指定的檔案時，會察看路徑中是否有此清單中的檔案，有的話就做為預設頁面回應

07.web.xml vs Annotation優先次序	
	在Servlet name相同的情況下，web.xml中的Servlet設定會覆蓋@WebServlet標註設定
	覆蓋後使用的路徑以web.xml為主，同時如果@WebServlet中的url-pattern被呼叫的話會回傳404-NotFound
	
08.無論是使用web.xml或是@WebServlet，請求的URI都只是一個邏輯名稱(Logical Name)，
	請求/hello不代表真的有一個檔案叫hello，而是由Web容器去對應處理請求的程式實體名稱(Phisycal Name)與檔案
	
09.Web容器部屬應用程式必要結構
	(1)WEB-INF:必定位於應用程式根資料夾下，其中內容無法透過HTTP直接請求獲得，需透過Servlet進行Forward轉發
	(2)web.xml:部屬描述檔必須位於WEB-INF
	(3)lib:放置jar，位於WEB-INF中
	(4)classes:放置編譯後的.java檔，放在WEB-INF中，編譯後的.class檔案需要有與套件名稱相符的資料夾結構

10.進階部屬設定-URI模式設定
	使用HttpServletRequest的getRequestURI()取得URI資訊：
	requestURI=contextPath + servletPath + pathInfo
	
	(1)環境路徑(ContextPath)
		可以使用HttpServletRequest的getContextPath()方法取得，此路徑決定了WEB容器應該要挑選哪一個WebApp
		(因為一個WEB容器上可能部屬多個webapps)
		當app環境路徑與WEB網站環境根路徑相同時，getContextPath()會回傳空字串
	
	(2)Servlet對應
		決定了使用哪個webapps之後會進行Servlet對應，這邊必須設定URI模式：
		
		-路徑對應(Path mapping): 
			"/"開頭"/*"結尾的URI模式
			EX. /guest/... 以guest開頭的都會交由該Servlet處理
		
		-延伸對應(Extension mapping):
			"*.開頭的URI模式"
			EX.設定為*.view的模式，則所有.view結尾的請求交由該Servlet處理
		
		-環境根目錄對應(Context root)
			空字串""是特殊的URI模式對應至環境根資料夾，同等於"/"的請求
			EX.環境根資料夾為app，則就是http://host:port/app/ 的請求
			此時pathInfo是"/"，servletPath與contextPath都是空字串
		
		-預設Servlet
			只包括"/"的URI模式，找不到適合的URI模式對應時，就會使用預設Servlet
			P.S有些Web框架如Spring MVC，會由一個Servlet來統一分配請求該Servlet的URI模式就會設為"/"
		
		-嚴格匹配(Exact match)
			路徑要進行嚴格對應，不符合者都不通過
			EX.設定路徑為/app/a.book則必須要完全一致
		
		若以上URI模式在設定時有重疊的部分，比對時會從最嚴格的開始符合。

	(3)Servlet路徑
		直接對應至URI模式資訊，且並不包含路徑資訊(PathInfo)以及請求參數(Request Parameter)
		可用HttpServletRequest中的getServletPath()方法取得，但在"/*"與""URI模式的情形下會回傳空字串
		
	(4)路徑資訊(PathInfo)
		指的是不包含環境路徑與Servlet路徑的額外路徑資訊，且不包括請求參數。
		若沒有額外路徑資訊則回傳null
		
11.靜態資源
		Webapp相依的JAR檔案中，可以放置Servlet JSP 自定義類別 工具類別 部屬描述檔等等，
		當請求的URI對應到的位置找不到其請求的資源時，會搜尋並使用JAR中的META-INF/resources/路徑下的對應檔案
		如果JAR中有使用標註的Servlet，WEB容器也可以讀取標注資訊、載入類別並註冊為Servlet進行服務

--------------------------------------------------------------------------------------------
CHAPTER03.請求與回應

01.HTTP請求訊息轉變為Java物件
	HTTP伺服器收到請求後會將支轉交給WEB容器，容器會建立一個代表當次請求的HttpServletRequest實例，
	並且將請求資訊剖析之後設定給此物件，同時建立一個HttpServletResponse物件作為回應瀏覽器的物件。
	其中資訊收集、請求&回應的訊息轉換、物件的建立與回收(生命週期)都有WEB容器負責進行

02.處理請求參數
	常用方法：
		(1)getParameter("name"):回傳指定名稱參數的值							:String
		(2)getParameterValues():表單若有複選元件如checkbox或List				:String[]
		(3)getParameterNames():	請求全部的請求參數名稱							:Enumeration<String>
		(4)getParameterMap():	以MAP型態傳回請求參數KEY:參數名稱 VALUE:參數值	:Map<String,String[]>
	
03.過濾請求參數
	現代瀏覽器可以直接在網址列輸入請求參數，瀏覽器會自動進行URI編碼，
	因此未經過濾的請求參數可以被用來進行注入攻擊(Injection)
	
04.處理請求標頭
	(1)getHeader(name):回傳指定標頭的值				:String
	(2)getHeaders():回傳指定標頭們名稱				:Enumeration<String>
	(3)getHeaderNames():回傳所有標頭名稱			:Enumeration<String>

	Enumeration轉為ArrayList:
		使用集合物件Collections(java.util)
		Collections
		.list(Enumeration<String>放這邊)
		.forEach(name -> {	//使用forEach遍歷
			System.out.printf("%s , %s", name , request.getHeader(name));
		})
	
		<P.S>標頭值本身是整數或日期的話可以用getIntHeader()/getDateHeader()取得轉換後的Date或Int,
			轉換失敗的話會拋出Exception
	
05.請求參數編碼處理
	(1)POST Request:
		若瀏覽器沒有在Header中設置Content-Type，使用HttpServletRequest.getCharacterEncoding()會得到null，
		這樣的情況下若容器的預設編碼和瀏覽器的不同就有機會得到亂碼，
		可以使用setCharacterEncoding("編碼類型")方法指定取得POST請求時的編碼，
		不過限定是設置requestBody當中的編碼(所以只適用POST)，且必須在取得請求值之前進行。
		建議將此步驟設計在Filter當中，避免反覆於Servlet中設定
		或是整個應用程式都統一的話可以設定在web.xml中設置
		<request-character-encoding>UTF-8</request-character-encoding>
		
	(2)Get Request:
		處理URI的是HTTP伺服器而非WEB容器，若要轉UTF-8可用以下方式處理編碼:
		String name = request.getParameter("name");
		String name = new String(name.getBytes("ISO-8859-1"),"UTF-8")
	
		<P.S>Tomcat8以後，附帶的HTTP Server預設使用UTF-8，便不需要自行轉換編碼了
		
06.Form表單的Enctype屬性
	當未設置Form表單的Enctype屬性時，預設為"application/x-www-form-urlencoded"
	需要上傳檔案時需要設置為enctype="multipart/form-data"
	
07.讀取請求本體的資料
	使用HttpServletRequest下的getReader()方法可以取得一個BufferedReader去讀取請求本體資料
	
08.取得上傳的檔案(參考書籍Page.3-23)
	(1)使用getInputStream()取得ServletInputStream(InputStream的子類別)，代表請求本體的串流物件
	<P.S>
		同一請求期間getReader()與getInputStream()只能擇一呼叫，
		兩者都呼叫會拋出IllegalStateException
		
	(2)使用getPart()處理上傳的檔案
		Servlet3.0之後可以使用getPart()來處理上傳的檔案，
		注意必須設置@MultipartConfig標註才能使用getPart()相關API

09.@MultipartConfig標註可以對Servlet處理上傳檔案的相關資訊做設置，可用屬性有:
	(1)fileSizeThreshold:整數值設定，檔案大小超過門檻會先寫入暫存檔，預設值為0
	(2)location:字串設定，設定寫入檔案的資料夾，可搭配Part的Write()使用，預設為空字串
	(3)maxFileSize:檔案上傳大小限制，預設值-1L，表示不限制大小
	(4)maxRequestSize:限制multipart/form-data請求個數，預設值-1L，表示不限制大小

10.取得上傳檔案名稱
	multipart/form-data發送的每個內容區段都有Content-Disposition:form-data的標頭資訊:
	包含屬性:
	(1)name
	(2)filename
	(3)Content-Type
	要取得上傳檔案名稱就是取得Content-Disposition標頭的值，然後取得filename屬性的值
	最後再用Java I/O API寫入檔案中

11.調派請求
	webapp中常需要多個Servlet完成請求，比如把另一個Servlet的請求處理流程Include進來，
	或是將請求轉發(Forward)給特定的Servlet處理，這些需求可以透過RequestDispatcher完成。
	
	RequestDispatcher:
	使用HttpServletRequest的getRequestDispatcher()方法取得"RequestDispatcher介面的實作物件"，
	(RequestDispatcher介面下包含include()與forward())
	也可以透過ServletContext的getRequestDispatcher()或getNamedDispatcher()來取得
	EX.取得dispatcher範例:
		RequestDispatcher dispatcher =
			request.getRequestDispatcher("some");
			dispatcher.include(request,response); -->include()方法
			
	(1)Include方法:
		將另一個Servlet流程包括進目前的Servlet流程中，
		如上request.getRequestDispatcher("some");之中的some實際會是依照URI模式取得對應的Servlet，
		也可以包含query String例如: req.getRequestDispatcher("some?data=123456")，
		如此在被include或forward的Servlet中就可以使用getParameter("data")獲得參數。
		<P.S>
			呼叫include()時必須分別傳入實作了ServletRequest,ServletResponse介面的物件，
			可以是service()傳入的物件，也可以是自定義的物件或Wrapper
		<P.P.S>
			使用include()時被包括的Servlet中任何對請求標頭的設定都會被忽略，
			被包括的Servlet可以使用getSession()取得HttpSession物件，
			HttpSession底層預設使用Cookie，因此response會加上Cookie請求標頭		
	(2)forward方法:
		呼叫forward()時同樣需要傳入request,response作為參數，
		要注意呼叫forward()時，目前的Servlet不能有任何的回應確認(Commit)，有Commit時會拋出IllegalStateException
		且若呼叫forward時在目前的Servlet透過回應物件設定了一些回應但未確認，
		這些回應在呼叫forward()後會被全部忽略->因此需要設置成response scope attribute去傳遞
		
	<P.S>
		include()與forward()作為調派的方式，是屬於容器內部的流程，
		瀏覽器並不會知道調派流程，因此網址列並不會發生變化。		
		
12.請求範圍屬性(Request Scope Attribute)
	使用include()或forward()時包括請求參數的作法只適用於傳遞字串值給另一個Servlet，
	在調派過程中如果有需要共用的"物件"，可以設定給請求物件成為屬性，稱為"請求範圍 屬性"
	相關方法如下:
		(1)setAttribute("name",Object):	指定名稱&物件設定屬性
		(2)getAttribute("name"):		透過指定名稱取得屬性
		(3)getAttributeNames():			取得所有屬性的名稱
		(4)removeAttribute("name"):		透過指定名稱移除屬性
		
13.設定回應標頭、緩衝區
	(1)設定回應標頭:
		HttpServletResponse物件的setHead()與addHeader()可以設定標頭
		-setHeader():設定標頭名稱與值
		-addHeader():在同一個標頭名稱上附加值
			這兩個方法接受String值，若標頭為Int或Date可用setIntHeader/setDateHeader，addHeader同理。
			
		搭配狀態碼：
			有些標頭需要搭配HTTP狀態碼(Status Code)，可以透過HttpServletResponse的setStatus()方法設定，例如：
				
				狀態碼					範例
				200	OK					response.setStatus(HttpServletResponse.SC_OK);
				301	Moved Permanently	response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
			
			注意：
				必須在response commit之前設定好標頭，若在commit之後設置會被容器忽略
	
	(2)對回應進行緩衝：
		容器"可以"(非必要)對回應進行緩衝，HttpServletResponse以下有幾個關於緩衝的方法：
			(1)isCommited():查看回應是否已確認
			(2)reset():重置回應資訊，會一併清除已設定的標頭
			(3)resetBuffer():只重置回應內容但不會清除標頭
			(4)flushBuffer():出清緩衝區中已經設定的回應內容
			(5)getBufferSize():取得緩衝區大小
			(6)SetBufferSize():需要在response.getWriter()或.getOutputStream之前呼叫，取得的輸出物件才會套用此設定
			
			-在緩衝區(Buffer Area)未滿或被出清之前，回應相關內容都不會真正傳到瀏覽器。
			-reset()/resetBuffer()需要在回應commit之前呼叫，否則拋出IllegalStateException
			-HttpServletResponse物件被容器關閉前會出清所有內容

14.HttpServletResponse物件被關閉的時機:
	(1)Servlet的service()方法結束
	(2)回應內容超過HttpServletResponse中setContentLength()設定的長度
	(3)呼叫sendRedirect()
	(4)呼叫sendError()
	(5)呼叫AsyncContext的complete()方法

15.設置輸出編碼方法：
	(1)設定Locale:
		瀏覽器若有發送Accept-Language標頭，可用HttpServletRequest的getLocale()獲得Locale物件，代表瀏覽器可接受語系
		setLocale()擇可以設定Locale物件資訊，包含語系與編碼資訊。語系會通過回應標頭Content-Language設定。
		setLocale()也會設定HTTP response的 Content-Language
		EX.
			response.setLocale(Locale.TAIWAN); --> HTTP回應的Content-Language變成zh-TW
		
	(2)使用setCharacterEncoding()/setContentType()
		若回應與接收請求參數都需要使用到中文，
		必須同時設定HttpServletResponse與Request的setCharacterEncoding()或setContentType()為正確編碼
		
		setContentType()會在回應中設定content-type回應標頭，只要指定MIME TYPE就可以了，
		也可以在web.xml中設定<mime-mapping>，包含<extension>中的附檔名對應到<mime-type>的指定MIME類型
		
		MIME目的：
			告訴瀏覽器他接下來將要接收到的輸出內容(串流)是何種類型的檔案，又該如何處理
			
16.暫時性重新導向
	除了第13點提到的設定HTTP Status Code與設定Location標頭之外，也可用HttpServletResponse的sendRedirect()達成
	要求瀏覽器重新請求一個另一個URI，指定相對URI或絕對URI都可以，例如:
	response.sendRedirect("https://openhome.cc");
	此方法會在回應中設定HTTP Status = 302 以及Location標頭，並使用GET方法請求指定URI->網址列會發生變化

--------------------------------------------------------------------------------------------
CHAPTER04.會話管理

01.何謂會話管理(Session Management)
	HTTP作為無狀態的通訊協定，伺服器不會記得此次請求以及下個請求之間的關係，
	若有些功能需要多次請求來完成，webapp就需要一個方法去記得本次請求與之後的請求間的關係。
	既然webapp不記得那就由瀏覽器在每次請求時主動告知
	
02.會話管理常用方式：
	(1)隱藏欄位(Hidden Field):
		以問卷作答來看，把上一頁的作答發給webapp並將之以隱藏欄位方式回應給browser,
		此方式在關閉網頁後就會遺失先前的資訊，且檢視頁面原始碼時可以看到隱藏的值
	
	(2)Cookie:
		在本次請求中把下一次請求時webapp應該知道的資訊先回應給瀏覽器，瀏覽器在後續請求一併發送給應用程式，
		webapp就可以得知多次請求的相關資料。
		原理:
			是瀏覽器儲存訊息的方式，webapp可以回應瀏覽器"set-cookie"標頭，
			瀏覽器收到後將此標頭與數值儲存為電腦上的檔案，這個檔案就稱為Cookie，
			可以設定一個存活期限給Cookie，關閉瀏覽器再重啟時若Cookie仍然存活，
			瀏覽器會用cookie標頭自動將cookie發給webapp，webapp就可以得到請求的相關訊息
		<P.S>Cookie儲存空間有限
		
		Servlet內建的部分Cookie相關API:
			(1)Cookie cookie = new Cookie("name","value"); - 指定名稱與數值
			(2)cookie.setMaxAge(7*24*60*60); -設定存活期限，單位是秒
			(3)response.addCookie(cookie);	-新增Cookie
			(4)request.getCookies();	-可以取得該網頁所屬網域的所有Cookie,回傳Cookie[]
			(5)cookie.getName()		-取得cookie名稱
			(6)cookie.getValue()	-取得cookie數值
		只憑Cookie簡單的憑據(Token)做驗證是危險的，因此需要一種更為安全的Token

		Cookie的安全性:
			(1)setSecure():
				透過把setSecure()設置為true，確保Cookie只能在連線有加密的情況下(HTTPS)傳送
			(2)setHttpOnly():
				會在Set-Cookie標頭上附加HttpOnly屬性，標示Cookie只能用在Http，
				在瀏覽器可支援的前提下，就無法使用javascript讀取Cookie了
				另外可以用isHttpOnly()方法得知目前是否有有設置為HttpOnly(回傳Boolean)
	
	(3)URI重寫(URI Rewriting):
		GET請求參數的應用，將相關資訊以超連結方式回應給瀏覽器，超連結中的URI把請求參數包進去，
		按下超連結時，就會一併發送請求參數。
		限制:
			URI重寫在超連結附加資訊，因此只適用於GET，且GET可攜帶的參數長度有限，
			因此要保留大量資訊的話不適用URI重寫的方式

03.HttpSession會話管理方式:
	使用HttpServletRequest的getSession()取得HttpSession物件，
	這個物件同樣有setAttribute()跟getAttribute()可以用來將資訊儲存為屬性，
	可以從Java應用程式觀點來做會話管理，暫時忽略HTTP其實是無狀態的事實
	
	(1)getSession():
		有兩個版本，無參數版本在尚未存在HttpSession物件時呼叫，會直接建立一個新物件回傳；
		另一個是有boolean參數版本getSession(boolean b)，傳入false時若尚未存在實例會直接回傳null。
	<P.S>	
		-若要讓HttpSession物件失效可以使用invalidate()方法 -->可用於登出時
		-基於WEB安全考量，登入成功後可使用changeSessionId()變更SessionID
		-呼叫過invalidate()讓HttpSession物件失效之後，後續進行request.getSession()得到的就是全新的HttpSession物件了
		-HttpSession並非執行緒安全(Thread safe)，multi-thread環境中需要注意設定屬性時共用存取的問題
		
	(2)WEB容器
		HTTP仍然為無狀態協定，數個請求間的關係實際上是由WEB容器負責
	(3)SessionID
		為每個HttpSession物件的特殊ID，預設用Cookie存放在瀏覽器，預設名稱為JSESSIONID，數值可用getID()取得

04.HttpSession管理原理
	(1)
		WEB容器是執行於JVM的Java程式，getSession()取得的HttpSession是WEB容器中的Java物件，
		HttpSession中的各項屬性自然也存在於WEB容器中。
		瀏覽器發出請求時會把Cookie中存放的SessionID發給應用程式，
		WEB容器根據SessionID找到對應的HttpSession物件，以此獲得會話資料
	(2)
		使用HttpSession管理時，屬性是儲存在WEB容器中，SessionID預設使用Cookie存放於瀏覽器，
		此Cookie存活期限預設為關閉瀏覽器後即失效。(Cookie若失效就無法發送SessionID)
		HttpSession會占用記憶體空間，不要儲存耗資源的大型物件，
		無需使用時記得invalidate()使其失效，否則要等到失效期間過後才被回收
	(3)
		可使用setMaxInactiveInterval()設定HttpSession的失效期間(多久沒接到請求就失效的期間)，單位為秒
		也可用web.xml <session-config>中的<session-timeout>設定，注意這邊單位是分鐘
	
05.SessionCookieConfig介面
	(1)SessionCookieConfig實作物件
		Sevlet3.0後，可以使用ServletContext物件(由Servlet實例呼叫getServletContext()獲得)
		呼叫getSessionCookieConfig()取得實作物件，此物件可以設定存SessionID用的Cookie其相關資訊，例如:
		-setName():設置預設為JSESSIONID的Cookie名稱
		-setAge():設置儲存SessionID的Cookie存活期限(預設為關閉瀏覽器就消滅，單位是秒)
		重點：
			SessionCookieConfig設定必須在ServletContext初始化之前
		修改方式：
			(1)web.xml:見書籍4-21
			(2)實作ServletContextListener:
				容器在初始化ServletContext時會呼叫ServletContextListener的ContextInitialize()
				