---JSP / SERVLET READING HIGHLIGHTS---

CHAPTER01.簡介WEB應用程式

01.URL / URN / URI的區別
	用來告訴瀏覽器取得文件檔案等資源的路徑
	(1)URL(Uniform Resource Locator):最早出現的標準
	(2)URN(Uniform Resource Name):代表某個資源獨一無二的"名稱"，與URL相同用來識別資源用
	(3)URI(Uniform Resource Identifier):最晚出現，URL與URN成為了URI的子集
	範例參照書籍page 1-5
	
02.何為HTTP
	HTTP作為一種通訊協定，定義了兩台電腦間的溝通方式，也就是Client與Server端連線、交換資訊的確認步驟
	有兩個基本的重要特性：
		(1)基於請求與回應(Request/Response)
			-沒有請求就不會有回應
		(2)無狀態協定(Stateless)
			-Web網站回應完成後，就不會記得瀏覽器的資訊(Request的生命週期僅限執行一次)
		
		<P.S>與HTTPS的區別
			HTTP傳送的資料都是明文(未加密的)，有安全上的疑慮，因此網景公司設計了SSL（Secure Sockets Layer）
			用以對HTTP傳輸的數據加密，於是誕生HTTPS(=HTTP+SSL)，一個可進行加密傳輸與身分認證的通訊協定
			
		HTTPS和HTTP的區別主要如下：
		1、https協定需要到ca申請證書，一般免費證書較少，因而需要一定費用。
		2、HTTP是超文本傳輸協定，資訊是明文傳輸，HTTPs則是具有安全性的ssl加密傳輸協定。
		3、HTTP和HTTPs使用的是完全不同的連接方式，用的埠也不一樣，前者是80，後者是443。
		4、HTTP的連接是無狀態的;HTTPS協定是由SSL+HTTP協議構建的可進行加密傳輸、身份認證的網路協定，比HTTP協定安全

03.常用的GET/POST請求
	(1)GET:
		向Web網站請求取得指定資源，除了發送取得資源的URI、請求參數之外也會一併發送標頭(Header)資訊，
		請求參數放在路徑的query String中，因此網址列中會出現參數資訊
	
	(2)POST:
		處理大量的資訊發送，同樣也有發送請求參數與Header，
		不過請求參數的位置在Header之後的訊息本體(Body Message)中，
		由於訊息本體長度不受限，所以可以處理大量資料的發送
		同時網址列也不會出現參數資訊，適合傳送較敏感資訊
		
	<P.S>雖然請求參數不會出現在網址列，但仍有可能遭到第三方攻擊而被截取，因此HTTPS的加密連線還是必要的
	<P.P.S>請求標頭(Header)
		提供WEB網站一些瀏覽器相關的資訊，方便透過這些資訊進行回應處理。例如：
		User-Agent中得知使用者的瀏覽器種類與版本
		Accept-Language了解瀏覽器接受那些語系的內容回應
	
04.安全方法與等冪方法
	(1)安全方法(Safe methods):
		實做應用程式時，避免有使用者非預期中的結果，如GET/HEAD對使用者來說是用來"取得"資訊，
		因此不該被拿來"修改"資訊，例如轉帳或刪除帳號，也因此GET確實是安全方法，並不能說GET比較不安全
		所謂安全與否並非指方法對Server是否產生副作用(Side Effect)，而是對使用者來說是否安全
		
	(2)等冪方法(Idmpotent methods):
		單一次請求造成的副作用，與同樣請求進行多次的副作用必須是相同的
		EX.執行Delete把某筆資料刪除，隨後多次執行delete結果會是該筆資料不存在而非刪除更多筆
		其中只有POST不符合等冪特性，因為每次送出POST要求指定URI接受Body中的請求參數會有不同
		也因此每次POST的副作用也會不同

05.REST架構(REpresentational State Transfer)
	基於HTTP1.0/HTTP1.1平行發展但不限於HTTP的架構，
	與HTTP雷同，此架構由Client/Server端組成，且兩者間的通訊機制也是無狀態的(Stateless)
	而RESTful則是代表一種"設計風格"，泛指符合REST架構原則的系統，例如：
	POST/book 		用來新增一筆資料
	GET/book/1 		用來取得ID為1的書
	DELETE/book/1 	用來刪除ID為1的書...
	
06.URI百分比編碼(或URI編碼)
	(1)URI保留字元
		URI保留字元中，常用的有「:」、「/」、「?」、「&」、「=」、「@」、「%」等字元，
		於網址列表達時需要將代表該字元的8個位元以16進制表示並接在%之後，例如「:」-->00111010
		轉換為16進制後為3A	因此使用%3A表示
	(2)中文字元
		URI編碼針對的是UTF-8編碼的8位元數值，若請求參數都是ASCII字元時，由於UTF-8在ASCII部分有相容因此沒問題，
		非ASCII字元例如中文，UTF-8使用3個位元組來表示，如「林」就會轉為E6.9E.97--> %E6%9E%97
		<P.S>若編碼為MS950的情況下，林-->只有兩個位元組，會變成%AA%4C因此Web網站處理參數時就要指定MS950編碼
		
07.前端技術與後端技術
	粗略來說，交給瀏覽器去執行的技術屬於前端的範疇，而執行於Web網站的屬於後端技術。
	例如：JSP/Servlet屬於後端技術，執行於Web網站的記憶體空間；JS屬於前端技術，執行於使用者電腦上的記憶體空間(瀏覽器上)
	兩者的記憶體空間實體位置不同，無法直接互動，需要透過網路經由HTTP進行互動與資料交換達成應用程式功能

08.何謂WEB容器	
	作為JSP/Servlet唯一認得並可以用來運行JSP/Servlet的HTTP伺服器，他是由Java寫成並運行於JVM之上的程式，
	不只是用來持有、保存物件的群集(Collection)物件，同時也掌管物件的生命週期與相關服務連結
	HTTP那些文字性的通訊協定，就是透過容器居中進行剖析與轉換成Java物件。
	只要JSP/Servlet撰寫時符合WEB容器標準規範，就可以在任何廠商時做的WEB容器上運行，
	不用管底層真正的HTTP伺服器為何(參考書籍Page 1-19)
	如同JVM介於Java程式與實體作業系統之間，WEB容器介於實體HTTP Server與Server之間
	
09.	
	瀏覽器<------>實體伺服器<--->HTTP伺服器程式<--->WEB容器<--->Servlet
	
	-瀏覽器的請求由HTTP伺服器轉給WEB容器，WEB容器剖析HTTP請求內容並建立各種物件(HttpSession,HttpServletRequest,...)
	-WEB容器根據URI決定使用哪個Servlet處理請求
	-Servlet根據HttpServletRequest決定如何處理並透過HttpServletResponse建立回應
	-WEB容器與HTTP伺服器溝通，HTTP伺服器將回硬物件轉為HTTP回應回傳給瀏覽器
	-JVM本身是伺服器上的一個可執行程式，WEB容器由這個JVM去啟動，Servlet又是執行在WEB容器之中
	-當有請求進來時，WEB容器會幫每個請求分配一個Thread
	-有多個請求時就有多個執行緒而非多次開關JVM
	
10.	WEB容器可以使用同一個Servlet處理多個請求，因此需要注意執行緒安全的問題避免資料錯亂

11.Servlet
	Servlet類別必須繼承HttpServlet，並且如果要輸出HTML的話需要透過Java的輸入輸出功能，
	如從HttpServletResponse取得的PrintWriter。
	不過Servlet主要用於定義Java程式邏輯，應避免用來輸出網頁內容，
	如需輸出網頁內容應該要選擇使用JSP
	
--------------------------------------------------------------------------------------------

CHAPTER02.撰寫與設定Servlet

01.關於HttpServlet
	要編譯Hello.java，類別路徑(ClassPath)中必須包含ServletAPI的相關類別
	若使用的是Tomcat，這些相關類別會封裝在Tomcat/lib中的servlet-api.jar當中。
	編譯出的.class檔則會出現在專案/build/classes資料夾中
	
02.Servlet介面的繼承與實作(簡易描述)
	Servlet介面中定義了Servlet的基本行為：init(),destroy(),service()等等
	包含管理生命週期與提供服務時需要呼叫的方法。
	Servlet定義相關的類別與介面都未於javax.servlet套件中
	與HTTP相關的類別或介面都位於javax.servlet.http套件中
	
	其中，HttpServlet類別繼承實作了Servlet介面的GenericServlet類別，並定義了GenericServlet中的抽象方法service()
	當接收到請求時，容器會呼叫service()方法，用來判斷HTTP請求的方式後再分別呼叫doGet,doPost
	<P.S>不要覆寫到service()方法，這會把HttpServlet中定義的HTTP預設處理流程給覆蓋

03.	@WebServlet標註
	使用@WebServlet Annotation可以讓容器自動讀取當中的資訊，
	除了URI路徑之外，也可提供更多資訊如:name(Servlet的名稱),loadOnStartUp的次序
	<P.S>
		當沒有設定Servlet name 的時候其預設值會是Servlet類別的完整名稱
		應用程式啟動後預設不會建立任何Servlet實體，除非有loadOnStartUp設定(預設值-1,必須設定一個>0的值，越小越優先)
		
04.部屬描述檔(Deployment Descriptor,DD)
	即是專案中的web.xml檔案，可用於定義Servlet的相關資訊，
	在Servlet3.0之前尚未有Annotation可以使用時都部屬描述檔定義Servlet資訊
	
05.環境根目錄(Context Root)
	<display-name>標籤中定義了"Web APP的名稱"，這僅是一個名稱並非等同於WebAPP的根目錄
	Servlet4.0以前並沒有規範如何定義WebAPP環境根目錄，因此各廠商有各自定義方式
	例如：Tomcat可以在META-INF/context.xml中設定環境根目錄，正常情況下預設應用程式資料夾作為環境根目錄
	使用Eclipse的話也可在專案右鍵/Properties/WebProjectSettings裡面去設定環境根目錄
	Servlet4.0開始可以在web.xml中使用<default-context-path>來建議預設環境路徑
	
06.<welcome-file-list>	
	作為請求的路徑沒有指定的檔案時，會察看路徑中是否有此清單中的檔案，有的話就做為預設頁面回應

07.web.xml vs Annotation優先次序	
	在Servlet name相同的情況下，web.xml中的Servlet設定會覆蓋@WebServlet標註設定
	覆蓋後使用的路徑以web.xml為主，同時如果@WebServlet中的url-pattern被呼叫的話會回傳404-NotFound
	
08.無論是使用web.xml或是@WebServlet，請求的URI都只是一個邏輯名稱(Logical Name)，
	請求/hello不代表真的有一個檔案叫hello，而是由Web容器去對應處理請求的程式實體名稱(Phisycal Name)與檔案
	
09.Web容器部屬應用程式必要結構
	(1)WEB-INF:必定位於應用程式根資料夾下，其中內容無法透過HTTP直接請求獲得，需透過Servlet進行Forward轉發
	(2)web.xml:部屬描述檔必須位於WEB-INF
	(3)lib:放置jar，位於WEB-INF中
	(4)classes:放置編譯後的.java檔，放在WEB-INF中，編譯後的.class檔案需要有與套件名稱相符的資料夾結構

10.進階部屬設定-URI模式設定
	使用HttpServletRequest的getRequestURI()取得URI資訊：
	requestURI=contextPath + servletPath + pathInfo
	
	(1)環境路徑(ContextPath)
		可以使用HttpServletRequest的getContextPath()方法取得，此路徑決定了WEB容器應該要挑選哪一個WebApp
		(因為一個WEB容器上可能部屬多個webapps)
		當app環境路徑與WEB網站環境根路徑相同時，getContextPath()會回傳空字串
	
	(2)Servlet對應
		決定了使用哪個webapps之後會進行Servlet對應，這邊必須設定URI模式：
		
		-路徑對應(Path mapping): 
			"/"開頭"/*"結尾的URI模式
			EX. /guest/... 以guest開頭的都會交由該Servlet處理
		
		-延伸對應(Extension mapping):
			"*.開頭的URI模式"
			EX.設定為*.view的模式，則所有.view結尾的請求交由該Servlet處理
		
		-環境根目錄對應(Context root)
			空字串""是特殊的URI模式對應至環境根資料夾，同等於"/"的請求
			EX.環境根資料夾為app，則就是http://host:port/app/ 的請求
			此時pathInfo是"/"，servletPath與contextPath都是空字串
		
		-預設Servlet
			只包括"/"的URI模式，找不到適合的URI模式對應時，就會使用預設Servlet
			P.S有些Web框架如Spring MVC，會由一個Servlet來統一分配請求該Servlet的URI模式就會設為"/"
		
		-嚴格匹配(Exact match)
			路徑要進行嚴格對應，不符合者都不通過
			EX.設定路徑為/app/a.book則必須要完全一致
		
		若以上URI模式在設定時有重疊的部分，比對時會從最嚴格的開始符合。

	(3)Servlet路徑
		直接對應至URI模式資訊，且並不包含路徑資訊(PathInfo)以及請求參數(Request Parameter)
		可用HttpServletRequest中的getServletPath()方法取得，但在"/*"與""URI模式的情形下會回傳空字串
		
	(4)路徑資訊(PathInfo)
		指的是不包含環境路徑與Servlet路徑的額外路徑資訊，且不包括請求參數。
		若沒有額外路徑資訊則回傳null
		
11.靜態資源
		Webapp相依的JAR檔案中，可以放置Servlet JSP 自定義類別 工具類別 部屬描述檔等等，
		當請求的URI對應到的位置找不到其請求的資源時，會搜尋並使用JAR中的META-INF/resources/路徑下的對應檔案
		如果JAR中有使用標註的Servlet，WEB容器也可以讀取標注資訊、載入類別並註冊為Servlet進行服務

--------------------------------------------------------------------------------------------
CHAPTER03.請求與回應

01.HTTP請求訊息轉變為Java物件
	HTTP伺服器收到請求後會將支轉交給WEB容器，容器會建立一個代表當次請求的HttpServletRequest實例，
	並且將請求資訊剖析之後設定給此物件，同時建立一個HttpServletResponse物件作為回應瀏覽器的物件。
	其中資訊收集、請求&回應的訊息轉換、物件的建立與回收(生命週期)都有WEB容器負責進行

02.處理請求參數
	常用方法：
		(1)getParameter("name"):回傳指定名稱參數的值							:String
		(2)getParameterValues():表單若有複選元件如checkbox或List				:String[]
		(3)getParameterNames():	請求全部的請求參數名稱							:Enumeration<String>
		(4)getParameterMap():	以MAP型態傳回請求參數KEY:參數名稱 VALUE:參數值	:Map<String,String[]>
	
03.過濾請求參數
	現代瀏覽器可以直接在網址列輸入請求參數，瀏覽器會自動進行URI編碼，
	因此未經過濾的請求參數可以被用來進行注入攻擊(Injection)
	
04.處理請求標頭
	(1)getHeader(name):回傳指定標頭的值				:String
	(2)getHeaders():回傳指定標頭們名稱				:Enumeration<String>
	(3)getHeaderNames():回傳所有標頭名稱			:Enumeration<String>

	Enumeration轉為ArrayList:
		使用集合物件Collections(java.util)
		Collections
		.list(Enumeration<String>放這邊)
		.forEach(name -> {	//使用forEach遍歷
			System.out.printf("%s , %s", name , request.getHeader(name));
		})
	
		<P.S>標頭值本身是整數或日期的話可以用getIntHeader()/getDateHeader()取得轉換後的Date或Int,
			轉換失敗的話會拋出Exception
	
05.請求參數編碼處理
	(1)POST Request:
		若瀏覽器沒有在Header中設置Content-Type，使用HttpServletRequest.getCharacterEncoding()會得到null，
		這樣的情況下若容器的預設編碼和瀏覽器的不同就有機會得到亂碼，
		可以使用setCharacterEncoding("編碼類型")方法指定取得POST請求時的編碼，
		不過限定是設置requestBody當中的編碼(所以只適用POST)，且必須在取得請求值之前進行。
		建議將此步驟設計在Filter當中，避免反覆於Servlet中設定
		或是整個應用程式都統一的話可以設定在web.xml中設置
		<request-character-encoding>UTF-8</request-character-encoding>
		
	(2)Get Request:
		處理URI的是HTTP伺服器而非WEB容器，若要轉UTF-8可用以下方式處理編碼:
		String name = request.getParameter("name");
		String name = new String(name.getBytes("ISO-8859-1"),"UTF-8")
	
		<P.S>Tomcat8以後，附帶的HTTP Server預設使用UTF-8，便不需要自行轉換編碼了
		
06.Form表單的Enctype屬性
	當未設置Form表單的Enctype屬性時，預設為"application/x-www-form-urlencoded"
	需要上傳檔案時需要設置為enctype="multipart/form-data"
	
07.讀取請求本體的資料
	使用HttpServletRequest下的getReader()方法可以取得一個BufferedReader去讀取請求本體資料
	
08.取得上傳的檔案(參考書籍Page.3-23)
	(1)使用getInputStream()取得ServletInputStream(InputStream的子類別)，代表請求本體的串流物件
	<P.S>
		同一請求期間getReader()與getInputStream()只能擇一呼叫，
		兩者都呼叫會拋出IllegalStateException
		
	(2)使用getPart()處理上傳的檔案
		Servlet3.0之後可以使用getPart()來處理上傳的檔案，
		注意必須設置@MultipartConfig標註才能使用getPart()相關API

09.@MultipartConfig標註可以對Servlet處理上傳檔案的相關資訊做設置，可用屬性有:
	(1)fileSizeThreshold:整數值設定，檔案大小超過門檻會先寫入暫存檔，預設值為0
	(2)location:字串設定，設定寫入檔案的資料夾，可搭配Part的Write()使用，預設為空字串
	(3)maxFileSize:檔案上傳大小限制，預設值-1L，表示不限制大小
	(4)maxRequestSize:限制multipart/form-data請求個數，預設值-1L，表示不限制大小

10.取得上傳檔案名稱
	multipart/form-data發送的每個內容區段都有Content-Disposition:form-data的標頭資訊:
	包含屬性:
	(1)name
	(2)filename
	(3)Content-Type
	要取得上傳檔案名稱就是取得Content-Disposition標頭的值，然後取得filename屬性的值
	最後再用Java I/O API寫入檔案中

11.調派請求
	webapp中常需要多個Servlet完成請求，比如把另一個Servlet的請求處理流程Include進來，
	或是將請求轉發(Forward)給特定的Servlet處理，這些需求可以透過RequestDispatcher完成。
	
	RequestDispatcher:
	使用HttpServletRequest的getRequestDispatcher()方法取得"RequestDispatcher介面的實作物件"，
	(RequestDispatcher介面下包含include()與forward())
	也可以透過ServletContext的getRequestDispatcher()或getNamedDispatcher()來取得
	EX.取得dispatcher範例:
		RequestDispatcher dispatcher =
			request.getRequestDispatcher("some");
			dispatcher.include(request,response); -->include()方法
			
	(1)Include方法:
		將另一個Servlet流程包括進目前的Servlet流程中，
		如上request.getRequestDispatcher("some");之中的some實際會是依照URI模式取得對應的Servlet，
		也可以包含query String例如: req.getRequestDispatcher("some?data=123456")，
		如此在被include或forward的Servlet中就可以使用getParameter("data")獲得參數。
		<P.S>
			呼叫include()時必須分別傳入實作了ServletRequest,ServletResponse介面的物件，
			可以是service()傳入的物件，也可以是自定義的物件或Wrapper
		<P.P.S>
			使用include()時被包括的Servlet中任何對請求標頭的設定都會被忽略，
			被包括的Servlet可以使用getSession()取得HttpSession物件，
			HttpSession底層預設使用Cookie，因此response會加上Cookie請求標頭		
	(2)forward方法:
		呼叫forward()時同樣需要傳入request,response作為參數，
		要注意呼叫forward()時，目前的Servlet不能有任何的回應確認(Commit)，有Commit時會拋出IllegalStateException
		且若呼叫forward時在目前的Servlet透過回應物件設定了一些回應但未確認，
		這些回應在呼叫forward()後會被全部忽略->因此需要設置成response scope attribute去傳遞
		
	<P.S>
		include()與forward()作為調派的方式，是屬於容器內部的流程，
		瀏覽器並不會知道調派流程，因此網址列並不會發生變化。		
		
12.請求範圍屬性(Request Scope Attribute)
	使用include()或forward()時包括請求參數的作法只適用於傳遞字串值給另一個Servlet，
	在調派過程中如果有需要共用的"物件"，可以設定給請求物件成為屬性，稱為"請求範圍 屬性"
	相關方法如下:
		(1)setAttribute("name",Object):	指定名稱&物件設定屬性
		(2)getAttribute("name"):		透過指定名稱取得屬性
		(3)getAttributeNames():			取得所有屬性的名稱
		(4)removeAttribute("name"):		透過指定名稱移除屬性
		
13.設定回應標頭、緩衝區
	(1)設定回應標頭:
		HttpServletResponse物件的setHead()與addHeader()可以設定標頭
		-setHeader():設定標頭名稱與值
		-addHeader():在同一個標頭名稱上附加值
			這兩個方法接受String值，若標頭為Int或Date可用setIntHeader/setDateHeader，addHeader同理。
			
		搭配狀態碼：
			有些標頭需要搭配HTTP狀態碼(Status Code)，可以透過HttpServletResponse的setStatus()方法設定，例如：
				
				狀態碼					範例
				200	OK					response.setStatus(HttpServletResponse.SC_OK);
				301	Moved Permanently	response.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
			
			注意：
				必須在response commit之前設定好標頭，若在commit之後設置會被容器忽略
	
	(2)對回應進行緩衝：
		容器"可以"(非必要)對回應進行緩衝，HttpServletResponse以下有幾個關於緩衝的方法：
			(1)isCommited():查看回應是否已確認
			(2)reset():重置回應資訊，會一併清除已設定的標頭
			(3)resetBuffer():只重置回應內容但不會清除標頭
			(4)flushBuffer():出清緩衝區中已經設定的回應內容
			(5)getBufferSize():取得緩衝區大小
			(6)SetBufferSize():需要在response.getWriter()或.getOutputStream之前呼叫，取得的輸出物件才會套用此設定
			
			-在緩衝區(Buffer Area)未滿或被出清之前，回應相關內容都不會真正傳到瀏覽器。
			-reset()/resetBuffer()需要在回應commit之前呼叫，否則拋出IllegalStateException
			-HttpServletResponse物件被容器關閉前會出清所有內容

14.HttpServletResponse物件被關閉的時機:
	(1)Servlet的service()方法結束
	(2)回應內容超過HttpServletResponse中setContentLength()設定的長度
	(3)呼叫sendRedirect()
	(4)呼叫sendError()
	(5)呼叫AsyncContext的complete()方法

15.設置輸出編碼方法：
	(1)設定Locale:
		瀏覽器若有發送Accept-Language標頭，可用HttpServletRequest的getLocale()獲得Locale物件，代表瀏覽器可接受語系
		setLocale()擇可以設定Locale物件資訊，包含語系與編碼資訊。語系會通過回應標頭Content-Language設定。
		setLocale()也會設定HTTP response的 Content-Language
		EX.
			response.setLocale(Locale.TAIWAN); --> HTTP回應的Content-Language變成zh-TW
		
	(2)使用setCharacterEncoding()/setContentType()
		若回應與接收請求參數都需要使用到中文，
		必須同時設定HttpServletResponse與Request的setCharacterEncoding()或setContentType()為正確編碼
		
		setContentType()會在回應中設定content-type回應標頭，只要指定MIME TYPE就可以了，
		也可以在web.xml中設定<mime-mapping>，包含<extension>中的附檔名對應到<mime-type>的指定MIME類型
		
		MIME目的：
			告訴瀏覽器他接下來將要接收到的輸出內容(串流)是何種類型的檔案，又該如何處理
			
16.暫時性重新導向
	除了第13點提到的設定HTTP Status Code與設定Location標頭之外，也可用HttpServletResponse的sendRedirect()達成
	要求瀏覽器重新請求一個另一個URI，指定相對URI或絕對URI都可以，例如:
	response.sendRedirect("https://openhome.cc");
	此方法會在回應中設定HTTP Status = 302 以及Location標頭，並使用GET方法請求指定URI->網址列會發生變化

--------------------------------------------------------------------------------------------
CHAPTER04.會話管理

01.何謂會話管理(Session Management)
	HTTP作為無狀態的通訊協定，伺服器不會記得此次請求以及下個請求之間的關係，
	若有些功能需要多次請求來完成，webapp就需要一個方法去記得本次請求與之後的請求間的關係。
	既然webapp不記得那就由瀏覽器在每次請求時主動告知
	
02.會話管理常用方式：
	(1)隱藏欄位(Hidden Field):
		以問卷作答來看，把上一頁的作答發給webapp並將之以隱藏欄位方式回應給browser,
		此方式在關閉網頁後就會遺失先前的資訊，且檢視頁面原始碼時可以看到隱藏的值
	
	(2)Cookie:
		在本次請求中把下一次請求時webapp應該知道的資訊先回應給瀏覽器，瀏覽器在後續請求一併發送給應用程式，
		webapp就可以得知多次請求的相關資料。
		原理:
			是瀏覽器儲存訊息的方式，webapp可以回應瀏覽器"set-cookie"標頭，
			瀏覽器收到後將此標頭與數值儲存為電腦上的檔案，這個檔案就稱為Cookie，
			可以設定一個存活期限給Cookie，關閉瀏覽器再重啟時若Cookie仍然存活，
			瀏覽器會用cookie標頭自動將cookie發給webapp，webapp就可以得到請求的相關訊息
		<P.S>Cookie儲存空間有限
		
		Servlet內建的部分Cookie相關API:
			(1)Cookie cookie = new Cookie("name","value"); - 指定名稱與數值
			(2)cookie.setMaxAge(7*24*60*60); -設定存活期限，單位是秒
			(3)response.addCookie(cookie);	-新增Cookie
			(4)request.getCookies();	-可以取得該網頁所屬網域的所有Cookie,回傳Cookie[]
			(5)cookie.getName()		-取得cookie名稱
			(6)cookie.getValue()	-取得cookie數值
		只憑Cookie簡單的憑據(Token)做驗證是危險的，因此需要一種更為安全的Token

		Cookie的安全性:
			(1)setSecure():
				透過把setSecure()設置為true，確保Cookie只能在連線有加密的情況下(HTTPS)傳送
			(2)setHttpOnly():
				會在Set-Cookie標頭上附加HttpOnly屬性，標示Cookie只能用在Http，
				在瀏覽器可支援的前提下，就無法使用javascript讀取Cookie了
				另外可以用isHttpOnly()方法得知目前是否有有設置為HttpOnly(回傳Boolean)
	
	(3)URI重寫(URI Rewriting):
		GET請求參數的應用，將相關資訊以超連結方式回應給瀏覽器，超連結中的URI把請求參數包進去，
		按下超連結時，就會一併發送請求參數。
		限制:
			URI重寫在超連結附加資訊，因此只適用於GET，且GET可攜帶的參數長度有限，
			因此要保留大量資訊的話不適用URI重寫的方式

03.HttpSession會話管理方式:
	使用HttpServletRequest的getSession()取得HttpSession物件，
	這個物件同樣有setAttribute()跟getAttribute()可以用來將資訊儲存為屬性，
	可以從Java應用程式觀點來做會話管理，暫時忽略HTTP其實是無狀態的事實
	
	(1)getSession():
		有兩個版本，無參數版本在尚未存在HttpSession物件時呼叫，會直接建立一個新物件回傳；
		另一個是有boolean參數版本getSession(boolean b)，傳入false時若尚未存在實例會直接回傳null。
	<P.S>	
		-若要讓HttpSession物件失效可以使用invalidate()方法 -->可用於登出時
		-基於WEB安全考量，登入成功後可使用changeSessionId()變更SessionID
		-呼叫過invalidate()讓HttpSession物件失效之後，後續進行request.getSession()得到的就是全新的HttpSession物件了
		-HttpSession並非執行緒安全(Thread safe)，multi-thread環境中需要注意設定屬性時共用存取的問題
		
	(2)WEB容器
		HTTP仍然為無狀態協定，數個請求間的關係實際上是由WEB容器負責
	(3)SessionID
		為每個HttpSession物件的特殊ID，預設用Cookie存放在瀏覽器，預設名稱為JSESSIONID，數值可用getID()取得

04.HttpSession管理原理
	(1)
		WEB容器是執行於JVM的Java程式，getSession()取得的HttpSession是WEB容器中的Java物件，
		HttpSession中的各項屬性自然也存在於WEB容器中。
		瀏覽器發出請求時會把Cookie中存放的SessionID發給應用程式，
		WEB容器根據SessionID找到對應的HttpSession物件，以此獲得會話資料
	(2)
		使用HttpSession管理時，屬性是儲存在WEB容器中，SessionID預設使用Cookie存放於瀏覽器，
		此Cookie存活期限預設為關閉瀏覽器後即失效。(Cookie若失效就無法發送SessionID)
		HttpSession會占用記憶體空間，不要儲存耗資源的大型物件，
		無需使用時記得invalidate()使其失效，否則要等到失效期間過後才被回收
	(3)
		可使用setMaxInactiveInterval()設定HttpSession的失效期間(多久沒接到請求就失效的期間)，單位為秒
		也可用web.xml <session-config>中的<session-timeout>設定，注意這邊單位是分鐘
	
05.SessionCookieConfig介面
	(1)SessionCookieConfig實作物件
		Sevlet3.0後，可以使用ServletContext物件(由Servlet實例呼叫getServletContext()獲得)
		呼叫getSessionCookieConfig()取得實作物件，此物件可以設定存SessionID用的Cookie其相關資訊，例如:
		-setName():設置預設為JSESSIONID的Cookie名稱
		-setAge():設置儲存SessionID的Cookie存活期限(預設為關閉瀏覽器就消滅，單位是秒)
		重點：
			SessionCookieConfig設定必須在ServletContext初始化之前
		修改方式：
			(1)web.xml:見書籍4-21
			(2)實作ServletContextListener:
				容器在初始化ServletContext時會呼叫ServletContextListener的ContextInitialize()
				可以在其中取得ServletContext進行SessionCookieConfig設定，
				Servlet4.0以後也可以通過ServletContext.setSessionTimeout()進行設定
				
06.生成SessionID
	若瀏覽器禁用Cookie，無法使用Cookie在瀏覽器儲存SessionID，此時如打算使用HttpSession進行會話管理，
	可使用encodeURL()方法進行URI重寫。
	encodeURL()在容器無法從Cookie中取得SessionID時會在指定的URI附上SessionID以便設定URI重寫時的超連結資訊
	encodeRedirectURL()可以在指定的重新導向URI附上SessionID訊息
	
--------------------------------------------------------------------------------------------
CHAPTER05.SERVLET API、過濾器與傾聽器

01.進階API
	WEB容器會生成ServletConfig實例，可以從這個物件獲得Servlet初始參數
	以及代表整個webapp的ServletContext物件。

02.Servlet實例建立流程
	WEB容器啟動後讀取Servlet設定資訊，將Servlet類別載入並實體化並為每個Servlet產生ServletConfig實例
	呼叫Servlet介面的init()，把ServletConfig當作引數傳入(注意這是在Servlet建立實例後才發生，建立實例時還沒有ServletConfig)
	這個過程在Servlet建立後只會發生一次，所以第一次都特別耗時，後續每個請求到來就呼叫Servlet實例的Service()進行服務

03.ServletConfig
	ServletConfig實例是每個Servlet的代表物件，容器為每個Servlet設定時都產生了一個Servlet與ServletConfig實例
	GenericServlet類別同時實作了ServletConfig介面,Servlet介面

04.GenericServlet類別
	(1)主要目的
		將初始Servlet呼叫init()時傳入的ServletConfig引數封裝起來
		在GenericServlet實作Servlet的init()的同時，也呼叫了另一個無參數的init()，
		轉寫Servlet時如果有一些需要在初始階段執行的動作就可以重新定義這個無參數的init()方法
	(2)實作方法
		GenericServlet也簡單實作了Servlet介面與ServletConfig介面定義的方法，
		可以透過ServletConfig來取得資訊，例如:
		-getServletConfig()			:ServletConfig
		-getInitParameter()			:String
		-getInitParameterNames()	:Enumeration
		-getServletContext()		:ServletContext
		同時HttpServlet類別繼承了GenericServlet類別，
		因此當我們撰寫Servlet extends HttpServlet的時候也可以使用上述方法取得必要資訊而不用意識到ServletConfig存在

05.初始參數(InitParameter)設定
	(1)使用標註設定
		getInitParameter(),getInitParameterNames()可以取得Servlet初始參數
		若要進行設定可以在@WebServlet使用@WebInitParam設定initParams屬性, EX:
		
		@WebServlet(name="test",urlPatterns="/test"
			initParams={
				@WebInitParam(name="P1",value="value1"),
				@WebInitParam(name="P2",value="value2")
			}
		)
		public class ServletConfigTest extends HttpServlet{
			private String param1;
			public void init() throws ServletException{
				PARAM1 = getServletConfig().getInitParameter("P1"); -->也可以直接getInitParameter("P1")
	
	(2)web.xml設定
		使用<init-param>等標籤設定，web.xml會覆蓋掉標註的設定(Servlet Name相同的情況下)，結構如下:
		<servlet>
			<servlet-name></servlet-name>
			<servlet-class></servlet-class>
			<init-param>
				<param-name></param-name>
				<param-value></param-value>
			</init-param>
			<init-param>
				<param-name></param-name>
				<param-value></param-value>
			</init-param>	
		</servlet>	

06.取得初始參數
	重新定義無參數的init()方法，在其中獲得初始參數
	(有參數的被GenericServlet類別拿去封裝ServletConfig了，不要呼叫錯)
	初始參數通常做為常數，習慣上將變數命名為upperCase(全大寫)

07.ServletContext物件
	此物件是"整個Webapp"的代表物件，在整個webapp載入容器後由容器生成，
	可以透過ServletConfig的getServletContext()方法獲取此物件，以下是幾個常用方法:
	(1)getRequestDispatcher():
		取得RequestDispatcher實例，指定路徑需要以"/"環境根目錄開頭，如此便可執行請求調派:include()或forward()
		<P.S>
			"/"作為開頭路徑稱為環境相對路徑(Context-relative)；沒"/"開頭稱為請求相對路徑(Request-relative)
	(2)getResourcePaths():
		想知道整個webapp的某個資料夾下有哪些檔案可以使用getResourcePaths()方法，他會傳回Set<String>包含資料夾中所有檔案
		需要以"/"環境根目錄開頭
	(3)getResourceAsStream():
		讀取webapp中的某個檔案時使用，需要以"/"環境根目錄開頭，執行後回傳InputStream實例

08.PushBuilder物件:
	為了避免在一次的TCP連線中多次對賜福端發出請求造成阻塞而生，PushBuilder讓Servlet在必要的時候
	可以主動推送資源到瀏覽器，減少了請求的次數(參考書Page.5-11)
	HttpServletRequest.newPushBuilder()獲得PushBuilder物件，若瀏覽器不支援HTTP/2則回傳NULL，
	取得PushBuilder後可以使用.path().addHeader()加入主動推送的資源進行推送
	
09.ServletContextListener
	WEB應用程式生命週期傾聽器，webapp在初始化或銷毀前會呼叫ServletContextListener中的
	contextInitialized()與contextDestroyed()並在呼叫時傳入ServletContextEvent物件
	可以透過ServletContextEvent.getServletContext()取得ServletContext
	並透過getInitParameter獲取初始參數
	<P.S>
		這邊的初始參數是ServletContext的初始參數，隸屬於整個webapp，在應用程式仍存活的整個期間都會存在(除非主動移除)
		這些參數是webapp存活期間所有Servlet需要共用的資料。
	<P.P.S>
		參數的生命週期差異
			依據Scope分為:
				(1)request/response層級		:單次請求與回應後消滅
				(2)Session層級				:預設透過Cookie進行紀錄，此Cookie預設存活至瀏覽器關閉後消滅
				(3)ServletConfig層級		:設置的初始參數屬於Servlet，在Servlet初始化時就會存在
				(4)ServletContext層級		:設置的初始參數屬於整個webapp，在應用程式建立時就存在直到應用程式關閉後消滅

		在web.xml中ServletContext的初始參數使用<context-param>標籤來定義初始參數
		<listener>與<listener-class>指定ServletContextListener介面的時做類別
		
10.獲得SessionCookieConfig		
	HttpSession的Cookie設定也可以透過ServletContext.getSessionCookieConfig()取得SessionCookieConfig進行設定
	不過這個動作要在應用程式初始時進行(要寫在contextInitialized(ServletContextEvent sce)裡面)
	
11.在ServletContextListener中動態新增Servlet
	可以在ServletContextListener中的ContextInitialized()之中呼叫ServletContext.addServlet()
	指定Servlet name之後再使用(自定義)建構式建構實例，最後用ServletRegistration.Dynamic的addMapping()方法
	指定Servlet的URI Pattern，範例:
	
	ServletRegistration.Dynamic servlet= 
		context.addServlet(
			"Test",new Test(建構子參數)	->設定Servlet名稱,使用建構子建立實例
		);
		servlet.setLoadOnStartUp(1);
		servlet.addMapping("/test") 	->設定URI模式
		
12.ServetContextAttributeListener介面:
	(1)
		當ServletContext屬性被設置、移除或替換時，若想收到通知可以實作此介面，
		以上事件發生時就會呼叫對應的attributeAdded(),attributeRemoved(),attributeReplaced()
	(2)
		希望容器部屬應用程式時實例化此介面的實作類別並註冊給應用程式，就在實作類別上標註@WebListener
		並implements ServetContextAttributeListener介面。
		也可以再web.xml用以下結構設定:
			<listener>
				<listener-class>要用來實作介面的class</listener-class>
			</listener>

13.HttpSession事件與監聽器
	與HttpSession相關的五個監聽器:
	(1)HttpSessionListener:監聽生命週期
		SessionCreated(HttpSessionEvent se):在起始呼叫
		sessionDestroyed(HttpSessionEvent se):在結束呼叫
		可以對HttpSessionEvent使用getSession()取得HttpSession物件對會話進行處理。
	
	(2)HttpSessionAttributeListener:監聽屬性的變化
		attributeAdded(HttpSessionBindingEvent se):新增屬性
		attributeRemoved(HttpSessionBindingEvent se):移除屬性
		attributeReplaced(HttpSessionBindingEvent se):置換屬性
		HttpSessionBindingEvent有getName()與getValue()的方法可以取得屬性設定或移除時指定的名稱與物件
		
	(3)HttpSessionBindingListener:物件綁定監聽器
		valueBound(HttpSessionBindingEvent event):加入Session
		valueUnbound(HttpSessionBindingEvent event):從Session移除
		讓即將加入HttpSession的物件實作此介面，在這個物件加入或移除時就會呼叫上面兩個對應的方法
		HttpSessionBindingEvent.getSession()可取得HttpSession物件
		
	(4)HttpSessionActivationListener:物件遷移監聽器，大多時候用不到
		sessionWillPassivate(HttpSessionEvent se)
		sessionDidActivate(HttpSessionEvent se)
		用在分散式環境，httpSession要從一個JVM轉移至另一個JVM時，要先序列化所有屬性物件此時呼叫sessionWillPassivate()
		遷移完成後對所有物件進行反序列化，並呼叫sessionDidActivate()
		
	(5)HttpSessionIdListener:SessionID變化監聽器
		sessionIdChanged()
		實作類別可以標註@WebListener或是在web.xml設定
	
14.HttpServletRequest事件監聽器:
	(1)ServletRequestListener:生命週期監聽器
		requestDestroyed(ServletRequestEvent sre)
		requestInitialized(ServletRequestEvent sre)
		ServletRequest初始化或結束前會呼叫上述兩個對應方法，可透過ServletRequestEvent獲得ServletRequest
		實作此介面的類別需要標註@WebListener或在web.xml設定
		
	(2)ServletRequestAttributeListener:屬性監聽器
		attributeAdded(ServletRequestAttributeEvent srae):新增屬性
		attributeRemoved(ServletRequestAttributeEvent srae):移除屬性
		attributeReplaced(ServletRequestAttributeEvent srae):置換屬性
		與HttpSessionAttributeListener雷同，srae有getName(),getValue()
		實作類別需要標註或在web.xml設定

	(3)AsyncListener:
		
	(4)ReadListener:
	
15.過濾器Filter
	位於service()方法"呼叫之前"以及"呼叫之後容器對瀏覽器發出HTTP回應前"，
	可以攔截"發送給Servlet的請求"以及"Servlet處理完請求後做出的回應"，
	並且可以對於攔截到的請求與回應做出改變。
	常用的有:
	效能量測、使用者驗證、字元替換與篩檢、編碼設定等等，
	作為應用程式額外且獨立於程式碼之外的元件，隨時可以新增也隨時可以輕鬆移除

16.實作過濾器
	Servlet4.0之前:需實作Filter介面並使用@WebFilter標註或在web.xml定義；
	Servlet4.0以後:新增了HttpFilter繼承自GenericFilter，可以直接繼承HttpFilter來實作Filter

	(1)Filter介面:需實作init(),destroy(),doFilter()三個方法
		public default void init(FilterConfig fc):
		public default void destroy():
		public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)
		
		-FilterConfig是過濾器設定資訊的代表物件，在定義過濾器時如果有設定初始參數可以使用getInitParameter()獲得
		-doFilter()方法類似於service()方法，請求到達容器後在容器呼叫Servlet的service()之前，可呼叫doFilter()做前置作業
		-若呼叫FilterChain當中的doFilter()方法，會執行下一個過濾器，如果沒有下一個過濾器則執行Servlet的service()方法
		-如果未通過上一個Filter就不會呼叫FilterChain的doFilter()，請求就不會傳給下一個Filter或Servlet-->攔截請求
		<P.S>
			實作Filter時應把它視為獨立元件，不用理會前後是否有其他Filter
	
	(2)GenericFilter與HttpFilter
		Servlet4.0後新增GenericFilter類別，實作了Filter,FilterConfig,Serializable介面
		會將FilterConfig以及Filter初始參數取得並做封裝(init(FilterConfig fc))-->參見Page.5-34
		GenericFilter子類別要定義Filter初始化可以重新定義無參數的init()方法
	
	(3)@WebFilter標籤
		使用上與@WebServlet類似，可以在其中設定URI-pattern,Filter名稱,指定Servlet名稱,初始參數
		同理可使用web.xml設置且xml優先級較高會覆蓋掉標註的設定

	(4)觸發時機
		預設為瀏覽器直接發出請求，透過RequestDispatcher調派的請求可以設定@WebFilter 的 dispatcherTypes
		
17.請求包裹器
	因為ServletRequest與HttpServletRequest物件無法直接修改某些資訊(例如請求參數)，
	若要修改你可能會想要親自實作HttpServletRequest與HttpServletResponse介面，
	然而把所有方法都實作過去太麻煩了，因此使用ServletRequestWrapper這個實作了ServletRequest介面的類別，
	重新定義自己想要的方法即可，同理HttpServletRequest也有HttpServletRequestWrapper可以用
	
	Wrapper在重新定義完需要的方法後，將原先的請求包裹起來，此時Filter和Servlet不會知道也不需要知道請求已經被包裹，
	維持照常呼叫原先預定要使用的方法即可(已經透過Wrapper重新定義過)
	
	回應包裹器見Page.5-42
	
18.非同步處理(詳細見Page.5-48)
	WEB容器為每個請求分配一個執行緒，若執行緒被一些長時間的請求占用會影響webapp的承載能力
	Servlet3.0後新增了非同步處理，可以先釋放容器分配給請求的Thread去服務其他請求，
	被釋放了Thread的請求交由應用程式本身分配的Thread去處理

--------------------------------------------------------------------------------------------
CHAPTER06.使用JSP

01.JSP最後也會經由容器進行:轉譯為Servlet原始碼->自動編譯為.class檔案->載入.class檔案然後生成Servlet物件
	
02.容器如何控制JSP生命週期
	轉譯後JSP就像Servlet一樣，初始化是由容器呼叫_jspInit()方法、容器呼叫_jspDestroy()方法是銷毀，
	當有請求到來時，容器呼叫_jspService()方法。
	呼叫這些方法的原因是因為：
		HttpJspBase類別繼承了HttpServlet類別(有init(),destroy(),service())，並且實作了HttpJspPage介面
	
	(1)HttpJspPage介面：	
		規範了jspinit(),jspDestroy(),_jspService()方法
		HttpJspBase下的三方法：
		init():		呼叫了jspInit(),_jspInit()，若想在JSP載入時進行初始化動作應重新定義jspInit()方法
		destroy():	則是呼叫了jspDestroy(),_jspDestroy()，若想做收尾動作應重新定義jspDestroy()方法
		service():	呼叫了_jspService()方法，在JSP轉譯後定義的程式碼轉譯在_jspService()，因此會在請求來時執行
		
03.隱含物件(Implicit Object)
	JSP有Implicit Object		


--------------------------------------------------------------------------------------------
CHAPTER07.使用JSTL


--------------------------------------------------------------------------------------------
CHAPTER08.自訂標籤

01.自訂標籤(Tag File, Simple File, Tag自訂標籤)
	當需求無法靠JSTL或是需要自訂更簡便的方法時可以自訂標籤庫來使用
	例如每個頁面如果都需要錯誤處理標籤，就可以將錯誤處理變成標籤檔案
	
	(1)Tag File
		附檔名是.tag的標籤檔案，必須存放於WEB-INF/tags的資料夾中，
		tag檔案:
			可以使用tag指示元素，給定兩個屬性：
				-description:純粹的文字描述
				-PageEncoding:告知容器這個tag的編碼
			另外也可以使用taglib指示元素引用其他標準標籤或自訂標籤庫

		使用tag檔案的JSP:
			使用taglib指示元素定義兩屬性:
				-prefix:前贅詞
				-tagdir:Tag檔案存放的位置(必須在WEB-INF/tags的子資料夾中)
	
		Tag File的 body-content屬性:<%@tag body-content="scripless" pageEncoding="UTF-8"%>
			scriptless(預設):標籤本體不能使用Scriplet元素
			empty:沒有本體內容，只能使用<html:XXX/>的形式，不能使用有Opening tag & Closing Tag的作法
			tagdependent:將本體內容當作純文字處理

02.TLD檔案(Page8-7)
	
03.Simple Tag自訂標籤(Page.8-12)
	在Tag File中建議不要撰寫Scriptlet，如果還是免不了要對Java物件操作，可以考慮Simple Tag，把Java寫在其中
	實作Simple Tag需要了解更多細節，以模仿JSTL<c:if>標籤，做出一個<f:if>為例：
	(1)建立.java檔繼承javax.servlet.jsp.targxt.SimpleTagSupport實作標籤處理器-->重新定義doTag()方法
	(2)建立.tld檔 給定uri作為對應給taglib指示元素用，給定name,tag-class,body-content,attribute(Page.8-10)屬性
	(3)使用時taglib指示元素找到對應URI的.tld再透過名稱與tag-class找到對應java檔
	
	生命週期:
		1.建立自訂標籤處理器實例
		2.呼叫標籤處理器的setJspContext()方法設定PageContext()
		3.巢狀標籤的內層標籤會叫setParent()並傳入外層標籤的實例
		4.設定標籤處理器的屬性(呼叫.java中的setXXX()方法)
		5.呼叫setJspBody()方法設定JspFragment實例
		6.呼叫doTag()方法
		7.銷毀標籤處理器實例
		
		每當JSP包括Simple Tag自訂標籤時，每一次的請求都會建立新的標籤處理器實例，執行doGet()後就銷毀這個實例，
		因此建議Simple Tag的實作中不要有耗資源的動作(例如龐大的物件、取得連線物件等等)
	
04.Tag自訂標籤
	透過Tag介面相關的類別來實作標籤，可以繼承javax.servlet.jsp.tagext.TagSupport實作標籤處理器
	繼承TagSuppot的類別中會覆寫doStartTag()方法，當JSP開始處理標籤時，會呼叫此方法並根據回傳直決定是否執行本體內容
	(1)回傳EVAL_BODY_INCLUDE	:執行本體內容
	(2)回傳SKIP_BODY			:不執行本體內容
	
	生命週期:(Page.8-27)
		實作Tag介面相關類別時，依照不同的時機要定義不同的doXXXTag()方法，依照需求回傳不同的值，
		TagSupport類別提供Iterator介面的基本實作，只要在繼承TagSupport後重新定義必要的方法即可
		
		JSP遇到TagSupport時的動作流程:
		1.嘗試從標籤池中(Tag Pool)找到可用物件，找到就直接用不然就建立新的
		2.呼叫標籤處理器的setPageContext()方法設定PageContext()
		3.巢狀標籤的內層標籤會叫setParent()並傳入外層標籤的實例
		4.設定標籤處理器的屬性(呼叫.java中的setXXX()方法)
		5.呼叫標籤處理器的doStartTag()依照回傳值決定是否執行標籤本體或呼叫doAfterBody(),doEndTag()
		6.將標籤處理器實例放入標籤池中以便重新使用
		
		注意Tag實例可以被重複使用，必要時可以在doStartTag()中進行狀態重置(否則可能會有狀態留存)，
		重置狀態的動作放在doStartTag()中進行，比方說把判斷用的boolean重置為true/false
		不要使用release()!!! 這是在標籤實例被銷毀回收前呼叫的
		
	
	回傳值與動作的對應:
	-doStartTag()		:回傳EVAL_BODY_INCLUDE或是SKIP_BODY，預設為SKIP_BODY
							在回傳EVAL_BODY_INCLUDE之後會先執行一次本體再呼叫doAfterBody()，因此本體已經執行過一次
	
	-EVAL_BODY_INCLUDE	:獲得此回傳值就執行方法本體
	
	-doAfterBody()		:"可以"回傳EVAL_BODY_AGAIN(相當於SimpleTag的doTag()呼叫了JspFragment的invoke())
							若回傳EVAL_BODY_AGAIN會再次執行本體，然後再度呼叫doAfterBody()直到回傳SKIP_BODY
							
	-SKIP_BODY			:不想執行本體時回傳此常數並呼叫doEndTag()
	
	無論有無執行本體，最後都會來到doEndTag()，這邊可能回傳:
		-EVAL_PAGE:執行自訂標籤後續的JSP頁面
		或
		-SKIP_PAGE:不執行自訂標籤後續的JSP頁面
		
05.Tag自訂標籤-取得本體執行結果
	需要透過繼承BodyTagSupport類別，BodyTagSupport類別繼承了TagSupport類別，
	BodyTagSupport將doStartTag()預設傳回值從EVAL_BODY_INCLUDE改為EVAL_BODY_BUFFER
	當doStartTag()回傳EVAL_BODY_BUFFER，會依序呼叫setBodyContent(),doInitBody()兩方法，然後再執行標籤本體
	
	執行過setBodyContent(),doInitBody()兩方法之後可以透過getBodyContent()取得BodyContent物件(Writer的子物件)
	包括了本體執行後的結果，可以使用BodyConten.getString取得字串回傳結果，
	若要輸出到瀏覽器，要在doEndTag()中使用pageContext的getOut()取得JspWriter物件進行輸出
	
	
	
--------------------------------------------------------------------------------------------
CHAPTER09.整合資料庫

01.使用JDBC六大步驟
	(1)導入JDBC driver
	(2)註冊JDBC driver
	(3)建立起一個連線
	(4)執行查詢或其他SQL指令
	(5)從ResultSet獲得資料
	(6)清理環境(關閉物件,把連線放回連線池)
	
02.應用程式與資料庫的溝通
	不少資料庫是獨立運行的伺服器程式，應用程式利用程式庫與資料庫伺服器進行網路通訊協定，
	進行資料CRUD的同時，也簡化了與資料庫溝通時的程式撰寫	

03.JDBC是甚麼
	全名為Java Database Connectivity ，作為Java連線資料庫的標準規範，
	被設計用來解決更換資料庫廠商或是應用程式跨平台時會遇到的資料庫連線相關問題。
	他定義了一組標準類別與介面，應用程式需要連線資料庫時就需要呼叫這一組API
	資料庫廠商會實作標準API中的介面，實作品通常稱為JDBC Driver
	有了一套共同的API，未來有更換DB需求時只需要變更JDBC Driver即可
	-->達到寫一個Java程式，操作所有資料庫
	(不過如果使用了兔訂於某資料庫的SQL語法、資料型態或內建函式呼叫在轉移時還是會需要修改)
	
04.要連線資料庫，需要在類別路徑ClassPath設定JDBC驅動程式，具體來說就是在類別路徑中設定JAR檔案	

05.JDBC Driver的四種類型
	(1)JDBC-ODBC Bridge Driver
		由微軟主導的連接標準，ODBC全名為Open DataBase Connectivity，基本上JDBC也是參考ODBC制定出來
		
		原理：驅動程式將JDBC的呼叫轉換為對ODBC驅動程式的呼叫，由ODBC驅動程式來操做資料庫
		優點：利用現成的ODBC架構，只需將JDBC轉乘ODBC，驅動程式實作簡單
		缺點：部分呼叫無法直接轉換，功能受限/ 轉換呼叫速度受限/ ODBC需在平台上先設定，也有跨平台限制
		
	(2)Native API Driver
		原理：以原生方式呼叫資料庫提供的原生API(通常用C/C++實作)，JDBC呼叫都會轉換為原生程式庫的呼叫
		優點：直接呼叫原生API，在速度上有機會是最快的
		缺點：使用原生程式庫，驅動程式本身與平台相依，無法實現跨平台，需要在使用前於各平台安裝設定驅動程式
		
	(3)JDBC-Net Driver
		原理：
			將JDBC方法呼叫，轉換為特定的網路協定(Protocol)呼叫，用來向與資料庫特定的中介元件進行協定操作
			中介元件再與資料庫進行操作
		優點：彈性很高，JDBC Driver與中介元件的協定是固定的，若需要更換資料庫系統只需要更換中介元件
		缺點：透過中介元件轉換，速度較慢，不過換得的架構上的彈性是使用這類型Driver的目的
		
	(4)Native Protocol Driver
		原理：將JDBC呼叫轉換為與資料庫特定的網路協定，以與資料庫進行溝通操作
		概述：將JDBC呼叫轉換為特定網路協定，驅動程式可以使用純Java展現，也可以跨平台，效能表現也不錯
		
06.JDBC Driver註冊
	很少自行撰寫程式碼，只要想辦法載入Driver介面的實作類別.class檔，就會完成註冊
	載入的方式有四種：(Page.9-12)
	(1)使用Class.forName()
	(2)自行建立Driver實作類別的實例(自己撰寫程式碼)
		java.sql.driver driver = new 廠商實作介面的類別();
	(3)啟動JVM時指定jdbc.drivers屬性
	(4)設定JAR中/services/java.sql.Driver檔案
		JavaSE6之後，JDBC4.0特性，只要在驅動程式實作的JAR檔/services資料夾中，放置一個java.sql.driver檔案，
		當中撰寫Driver介面的實作類別名稱全名，DriverManager就會自動讀取這個檔案，找到對應類別完成註冊

07.取得連線物件(Connection實作物件)			
	透過DriverManager.getConnection()產生，建立時需要三個引數分別是：
	(1)使用者名稱
	(2)密碼
	(3)JDBC URI
		這個定義了連接資料庫時的協定、子協定、資料來源識別，結構是：
		協定:子協定:資料來源識別 
		除了協定固定jdbc開頭之外，各加時做廠商的URI格式都不相同，需要查詢各家的手冊
		Connection conn = DriverManager.getConnection(jdbcuri,username,password);
		
	DriverManager在底層會逐一嘗試Driver取得連線，成功時回傳Conn物件，過程中有紀錄的例外就拋出，
	全部嘗試過也無法取得Conn物件也會拋出例外。可使用isConnectedOK()看看是否連線成功。	

08.關閉Connection物件
	操作完資料庫齁需要關閉Connection物件釋放資源，可以使用isClose()測試與資料庫連結是否關閉，
	JDK7以後，Connection,Statement,ResultSet等介面都是java.lang.AutoCloseable的子介面，
	可以使用try-with-resource寫法使其用完後自動關閉，
	就可以不用寫原本的try-catch-finally結構
	
09.Statement物件
	Connection建立後，若要執行SQL需要先建立Statement物件作為陳述SQL的代表物件，
	使用conn.getConnection()建立Statement物件，取得後可以使用executeUpdate() / executeQuery() 執行SQL
	executeUpdate()	:
		主要用來執行Create table, insert, drop table, alert table等會改變資料庫內容的SQL，
		回傳int結果表示資料變動筆數。
	executeQuery()	:
		主要用於Select等查詢的SQL，會回傳javas.sql.ResultSet物件代表查詢結果，會是一筆一筆的資料
		資料的指示位置(cursor)一開始會在第一筆資料"之前"，可以透過resultSet.next()移動到下一筆
		
10.ResultSet物件
	取得查詢結果物件後，可以使用getXXX()取得資料EX.getString(),getInt(),getDouble(),getFloat()，
	可以使用"欄位名稱"當作引數傳入上述方法，取得對應欄位名稱的型態資料，
	也可以使用正整數(從1開始)當引數傳入，依照欄位順序取得資料

11.Excute()方法	
	此方法會在執行SQL時自動測試SQL是執行查詢或是更新，
	當回傳true的時候表示SQL將執行查詢並回傳resultSet，可以使用getResultSet取得結果，
	回傳false時表示SQL執行更新，將會回傳變動資料筆數或沒有結果，可使用getUpdateCount()取得更新筆數
	
12.關閉物件
	Statement, ResultSet不使用時可以使用Close()關閉，當Statement關閉時關聯的ResultSet也會自動關閉

13.PreparedStatement, CallableStatement物件
	
	PreparedStatement:
		解決使用+號串聯SQL語句的不便，當語句中只有參數不同時，
		可以使用PreparedStatement()方法預先編譯(precompile)SQL語句的部分(加快速度)參數的部分使用佔位字元"?"暫時填充
		後續使用prepareStatement.setInt()/.setString()/.setXXX()的方式進行設置
		設置時需要傳入兩個引數分別是int(表示第幾個佔位字元),內容(符合setXXX的資料型別內容)，範例:
		setString(1,"JOE")-->第一個佔位字元填入字串"JOE"
		
	CallableStatement物件基本上與PreparedStatement差異不大，主要用於呼叫預存程序，
	也表示應用程式將與資料庫產生直接的相依性。

	在使用這兩個物件時需要注意SSQL的資型態與Java資料型態的對應
	
14.JNDI
	將伺服器設置的從程式碼獨立出來，比如username,password,uri,資料庫實體位址,port,名稱...等，
	將這些東西設定好，將web.xml & context.xml的<Resource/>定義好之後，
	開發者唯一需要知道的就只剩下JNDI名稱，只需透過JNDI名稱找到DataSource並取得connection物件
	
15.ResultSet物件(Page.9-28)	
	(1)
		JDBC2.0開始，ResultSet可以使用previous(),first(),last()等方式移動cursor，
		也可以呼叫updateXXX(),updateRow()等方法來修改資料。
	(2)
		使用Connection建立statement/preparedStatemant時可以指定結果集類型以及並行方式
	(3)
		對於資料的捲動(cursor的移動) & 是否可以使用resultSet修改資料也可以進行設定

16.BLOB / CLOB型別
	(1)BLOB(Binary Large Object)	:用以儲存大量的二進制資料，如圖片、影音等等
		可以使用pstmt.setBlob()來做資料的設定
		ResultSet.getBlob()取得Blob()物件
		Blob擁有.getBinaryStream(), .getBytes()方法，可以取得欄位來源的InputStream或是Bytes[]
		.setBinaryStream(), .setBytes()則可以設定代表輸入來源的InputStream以及byte[]資料
		
	(2)CLOB(Character Large Object)	:用以儲存大量的文字資料
	
17.交易(Transaction)(Page.9-40)
	
	(1)四大特性：(簡稱ACID)
		(1)原子性(Atomicity)			:一個交易為一個單元工作(Unit of Work)，其中數個步驟，只有全部成功或是全部失敗
											只有全部都成功才COMMIT，任何一步失敗都會造成ROLLBACK
		(2)一致性(Consistency)			:交易相關的資料集合在交易前後需要一致，交易成功就應該在操作後的狀態，
											若交易失敗就應該回到交易前的狀態
		(3)隔離行為(Isolation behavior)	:在多人環境下，使用者各自進行交易且交易之間互不干擾
		(4)持續性(Durability)			:交易一旦成功其結果必須保存下來，即使系統掛了結果也不能遺失
	
	(2)ROLLBACK位置設定
		交易管理時想撤回某個SQL執行點可以設定儲存點(savepoint)
		point= conn.setSavepoint();
	
	
18.資料更新時可能發生的不一致問題(Page.9-44)
	(1)更新遺失(Lost Update)
		一個交易對欄位進行更新的資訊被另一個交易介入而導致遺失更新效力，發生在交易未隔離的情況
	
	(2)髒讀(Dirty read)
		兩交易同時進行，其中一個更新後未確認時，另一個交易就讀取那個資料
	
	(3)無法重複讀取(Unrepeatable read)
		某個交易兩次讀取同一欄位的資料並不一致，例如A交易在B交易更新前後進行讀取
	
	(4)幻讀(Phantom read)
		同一交易期間讀取到的資料筆數不一致，如A交易在B交易進行會變動到資料筆數更新的前後進行讀取
		
19.METADATA簡介
	MetaData是詮釋資料的資料，可透過Connection.getMetaData()取得DataBaseMetaData,
	透過此物件取得資料庫整體資訊；ResultSet也有getMetaData()可以取得MetaData物件...
	
20.JSTL有提供的SQL標籤庫作為JDBC程式碼的替代(Page.9-53)

--------------------------------------------------------------------------------------------
CHAPTER10.WEB容器安全管理

01.四個安全基本特性：
	(1)驗證(Authentication)
		確認當前溝通對象身分是否有權限
	(2)資源存取控制(Access Control for resources)
		基於完整性、機密性、可用性限制等目的對資源的存取設限
	(3)資料完整性(Data Integrity)
		資訊傳輸期間必須保證資訊的內容不被第三方修改
	(4)資料機密性或隱私性(Confidentiality or Data Privacy)
		只讓具有合法權限的使用者存取特定資料
		
--------------------------------------------------------------------------------------------
CHAPTER11.Java Mail入門

01.要使用JavaMail傳送郵件首先必須建立代表當次郵件會話的javax.mail.Session，
	Session包括了SMTP郵件伺服器位址、連接埠、使用者名稱、密碼等資訊
	
--------------------------------------------------------------------------------------------
CHAPTER12.Spring框架概論

01.Spring的核心功能
	(1)依賴注入(Dependency Injection)
	
	(2)控制反轉(Inversion of Controll)	
	
	(3)AOP(Aspect-Oriented Programming)