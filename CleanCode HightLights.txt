---HIGHLIGHTS FOR CLEAN CODE---

CHAPTER01.無瑕的程式碼

1.足夠專注：
	每個方法、類別、模組都應該要盡可能使目的變得單一且明確，
	一段Code應俐落地闡述一個清楚的概念，提高可讀性
	
2.可被原開發者以外的人員閱讀與增強，且應使包含單元測試與驗收測試。

3.使用有意義的名稱(良好的命名習慣)

4.一項任務僅透過一種途徑達成(避免重複)

5.提供清楚且盡可能少的API，並盡可能減少相依性

6.具有最少數量的實體(Entity)，包含類別、方法、函式、或其他類似的實體

---
CONCLUSION:
	減少重複、命名須具有高度表達力、及早建立簡單抽象概念
	
-------------------------------------------------------------------------	

CHAPTER02.有意義的命名

1.良好的命名應該要能夠明確的"展現意圖"

2.何謂展現意圖：
	展現意圖是讓讀者能夠在閱讀時立即明白一段Code的"目的與作用"，
	問題通常不是出在Code不夠簡潔，而是在於Code的"隱含性"
	-->即是Code的上下文資訊無法被程式明確展現出來的程度。
	
3.避免使用與原意相違背的詞，造成誤導 Ex.變數名稱取名為accountList但其型態並非List

4.避免使用過於相似(僅有細微不同)的名稱，導致判斷時間增加、閱讀效率降低

5.假使名稱必須有所不同，他們也應代表不同的意義，避免為了滿足Compiler的限制而無意義的命名

6.使用單一字母的命名和數值無法容易地在一篇文字中搜尋到，儘可能使用可以被搜尋的名字

7.通常也只有在宣告小的函式內的區域變數時才會使用單一字母

8.類別命名應使用名詞進行命名；方法應使用動詞或是動詞片語

9.當建構子被overloaded的時候，請使用名稱中含有參數資訊的靜態工廠方法 Ex.
	Complex fulcrumPoint = Complex.FromRealNumber(23.0);
	上述的作法比下方的作法恰當些，使讀者擁有更多資訊
	Complex fulcrumPoint = new Complex(23.0);

10.相同的概念儘量使用同一單字進行代表 Ex.driver/Controller/Manager三者概念上雷同擇一即可

11.盡量選用解決方案領域或是問題領域的命名(確保擁有共通的知識與文化背景)

-------------------------------------------------------------------------

CHAPTER03.函式

1.首要準則：簡短！

2.每個函式以簡短為前提，也必須有強大的意圖(明確的目的)，從一個函式帶領讀者至下個函式

3.一個函式應該只做一件事情，一層層引導往其他下面一層的函式，逐步闡明最初的函式要做的事情

4.函式的參數數量越少越好，盡可能不要超過三個(除非有特殊的理由)
	零參數函式(niladic)
	單參數函式(monadic)
	雙參數函式(dyadic)
	三參數函式(triadic)
	多參數函式(polyadic)
	
5.參數盡量少的原因之一：
	從測試的角度來看，使用參數是一件困難的事情。因為要寫出一個案例
	在各種參數可能的組合下都能work。

6.旗標(flag)參數
	將boolean作為參數傳給函式會使方法的署名(定義方法的第一行)變得複雜，
	同時也等同於宣告了此函式做了超過一件的事情(true / false 各一件)
	因此應盡量避免

7.物件型態的參數
	當一個函式需要超過兩個或三個參數時，很可能需要將其中的一兩個參數包在一個類別裡
	
8.注意各種各樣的耦合，盡可能降低，避免不必要的錯誤

9.輸出型的參數
	盡量避免使用輸出型的參數，容易葬成誤會且必須去察看函式的宣告才能釐清，
	如果函式必須要改變物件的某項狀態，就讓該物件改變本身的狀態吧

10.指令與查詢分離
	有些Code會把要執行的任務&是否執行此任務的判斷放在同一個方法當中，
	並把此方法直接放在if條件式內，此舉容易造成讀者的困惑及誤會，
	應把兩者分開來，判斷的指令(Command)放在if條件式中，查詢(query)放在要執行的區域
	
11.使用例外處理取代回傳錯誤碼
	避免使用指令型函式回傳錯誤碼，除了違背指令/查詢分離的原則，也會導致巢狀結構變深，
	當錯誤碼被回傳時，就是要求呼叫者立刻處理此錯誤。使用例外處理能更好的作簡化。

12.將Try/Catch區域提取出來
	整個Try/Catch混在Code裡面挺難看的，可以把Try/Catch的部分提取到一個函式當中，
	可以讓人更好的理解這個函式就是用來處理Exception用的，也把程式碼跟錯誤處理良好的區隔開來。
	一個函式只做一件事，錯誤處理本身就是一件事。
	
13.為何應避免使用回傳錯誤碼	
	若使用此方法，通常代表存在了一個類別或列舉(Enum)定義了所有的錯誤碼。
	這樣的類別依附性極強，讓許多其他類別必須import他，當這個定義所有錯誤碼的類別有修改時，
	所有相關的類別就需要重新Compile並部屬。
	如果使用例外處理，新的例外可以由例外類別衍生出來，不必重新編譯與部屬。

14.DRY原則 (Don't Repeat Yourself)不要重複程式碼

15.結構化程式設計
	每個函式以及函式當中的每個區塊，都應該只有一個進入點與離開點
	意即:只能有一個return敘述、迴圈內不能有break或continue、避免使用goto
	
-------------------------------------------------------------------------

CHAPTER04.註解

1.開宗明義
	註解是為了彌補Code表達力不足的"失敗"，不準確的註解遠比沒有註解還糟糕，該把註解減至最少

2.不準確的註解
	註解容易隨著時間，程式碼被搬來搬去而疏於維護，逐漸變得不準確並誤導讀者。
	
3.真正有用的註解類型：
	(1)法律型的註解：公司的程式撰寫標準規範
	(2)資訊型註解：提供基本資訊，如提示抽象方法回傳值或一個正規表示式的格式，但仍可被更好的命名取代
	(3)解釋意圖：簡單描述設計師選擇此作法的原因
	(4)對於後果的告誡：警告執行後的特殊後果
	(5)TODO List : 但要記得定期審視並更新
	(6)放大重要性
	(7)公共API裡面的Javadoc：要注意Javadoc也可能像其他註解一樣不夠精確並誤導讀者

4.當可以使用含式或變數名稱表達時就別用註解

5.註解起來的程式碼
	開發中圖個方便沒問題，但到了完成後還有整塊整塊註解起來的程式碼會很討厭，
	可能已經沒用了，但讀者看到時會沒有勇氣刪除掉，日積月累地變成殘渣
	現在已經有很多優秀的版本控制系統，已經逐漸沒有必要這麼做了

6.註解需要確保他只提供對應該區域程式碼的描述，不要在區域性註解提供全域的資訊

7.不要把一些關聯不顯著的描述或是過多的資訊塞到註解中

-------------------------------------------------------------------------

CHAPTER05.編排

1.開宗明義
	程式碼的風格以及可讀性會在程式中立下先例，持續影響可維護性以及可擴充性。
	即使經過大幅修改甚至最初的程式碼已經消失，風格以及紀律仍會留存

2.利用空白行來分隔套件、類別以及不同的方法(或各種不同的概念)，達到視覺上的提示

3.垂直距離與密度
	注意程式碼的垂直密度與垂直距離，密度表示上下文的關係密切度，
	垂直距離盡可能維持在一頁的視線範圍內，相似的概念彼此應盡可能地靠近

4.變數宣告
	變數宣告的位置應該要盡可能靠近他們被使用的位置
	區域變數宣告的位置應在一個函式的最上方，迴圈的控制變數應宣告在迴圈的敘述裡
	少數稍長的函式裡的變數可能會宣告在區塊的最上方或迴圈開始前
	
5.實體變數(Instance Variables)
	應被宣告在類別的上方，因為在設計良好的情況下，有許多方法會使用到這些變數
	
6.相依函式(Dependent Functions)
	某個函式呼叫了另一個函式(兩者互有關連)的情況下，
	此兩者在垂直的編排上應該要盡可能地靠近，如果可能的話呼叫者應在被呼叫者上方
	保持自然的順序有助於增加可讀性。
	
7.水平編排寬度約80-100字元較為合適(可以不超過80為佳)，上限不要超過120字元

8.水平的空白間隔與密度
	可以透過水平的空白間隔使運算子更為突出，也可以用來強調運算子的優先權
	不過很有可能使用自動編排工具編排後就被消失了...= =

9.縮排
	為了明確強調出各個scope的階層結構：
		檔案→類別→方法→母程式區塊→子程式區塊→...
		每個階層都是一個scope

10.空視野結構
	有時候whike或是for迴圈區塊內的程式碼是空白的，
	可以用大括號將空白區域框出並適當縮排，維持視覺的一致性

11.團隊應設置一個共同準則共同遵守

-------------------------------------------------------------------------

CHAPTER06.物件與資料結構

1.資料的抽象化
	將實現的過程隱藏起來，不只是在變數上加上一層函式的介面而已，
	將實現的過程隱藏其實就是一種抽象化的過程！
	class也不僅僅只是透過getter跟setter讓人存取變數，
	同時也是讓使用者在不知道過程的狀態下去操縱資料的本質。
	
	換句話說：
		較具體的狀況下，我們可以分辨出這些函式只是變數的存取器
		較抽象的狀況下，我們對於其內部資料態一無所知

2.資料/物件的反對稱性
	
	物件：
		將資料放在抽象層後方隱藏起來，並將操縱這些資料的函式暴露在外。
	
	資料結構：	
		直接將資料暴露在外，同時也沒有提供有意義的函式。
		
	二者的定義是對立同時也是互補的：
		使用資料結構的程式碼容易添加新的函式而不用變動已有的資料結構，
		反過來說難以添加新的資料結構，因為需要改變所有函式；
		
		使用物件導向的程式碼容易添加新的類別而不用變動已有的函式，
		反過來說難以添加新的函式，因為需要改變所有的類別。

3.德摩特爾法則(The Law of Demeter)：
	模組不該知道它所操縱物件的內部運作，這告訴我們，物件不該透過存取者暴露其內部結構
	詳細地說，一個類別C其中的方法f應該只能呼叫下列事項：
		(1)C類別
		(2)任何由f產生的物件
		(3)任何作為參數傳遞給f的物件
		(4)C類別中實體變數所持有的物件
		-->除此之外不該呼叫任何函式回傳的"物件"(因物件的內部應該要是隱藏起來的)
		
4.火車事故(train wreck)
	將一連串相連的程式呼叫，通常被認為是一種懶散的程式風格，EX.
	final String d = a.getB().getC().getD();	
	應把這些Code分開為：
	B b = a.getB();
	C c = b.getC();
	final String d = c.getD();
	
	(1)	若b,c,d為物件的情況下，這也違反了德摩特爾法則，
		因為在getB()的回傳物件上呼叫了getC()，甚至繼續往下面的回傳物件呼叫getD()
		理論上物件的內部結構是不該暴露的
		
	(2)	但若b,c,d並非物件，只是一種無其他行為的資料結構的話，本質上必然會揭露其內部結構，
		則在這樣的情況下德摩特爾法則就不適用。
	
	getter(存取器)的使用有可能會使人搞混這個問題。
	當資料結構沒有函式只使用公用變數時、
	或是物件只有private變數以及public函式時，這個問題就相對沒那麼令人疑惑。
	例如在Java Bean的標準下，即使在一個簡單的Class當中也必須要有getter, setter
	
5.避免產生"混合體"
	所謂混合體即是半物件半資料結構，擁有函式去執行一些重要的事情，
	同時也有public變數以及public的getter, setter，並且讓其他外部函式使用這些private變數
	這樣會使得程式難以添加新的函式，同時也難以添加新的資料結構
	
6.隱藏結構
	回到上述第4.點的範例，若a是一個物件，我們應該要下指令讓a去執行某某事情，
	而非透過其他方法得知它的內部結構，因此可以試著將一整串的呼叫放在如下的方法中：
	final String d = a.generateStrD();
	讓物件a隱藏其內部結構，也壁面原先的函式對其內部進行探索。
	
7.資料傳輸物件(Data Transfer Objects, DTO)
	最佳的資料結構形式，一個類別中只有public變數且沒有任何函式。
	通常用在取得資料庫原始資料後欲將其轉成應用程式物件的第一階段。
	
8.Bean物件
	與DTO相比更常見的形式，Bean物件擁有半封裝特性，以及可以被getter, setter操作的private變數
	兩者(DTO & Bean物件)作用基本相同，但Bean可以讓物件導向支持者有比較好的使用感受
	
9.活動紀錄(active records)
	是一種特殊的DTO，是擁有public變數(或可以讓Bean存取)的 "資料結構"，
	由db table 或是 dataSource直接轉換而來，並且通常擁有save 與 find 等瀏覽方法
	但是切記它是"資料結構"，請不要把它當成物件並且加入商業邏輯的方法，
	會生出資料結構與物件的混合物。

---
CONCLUSION:
	在一個給定的系統上，
	我們有時希望這部分能有"增加新資料型態的彈性"-->因此選用物件導向設計
	其他部分我們若希望能有"增加新行為的彈性"-->偏好資料型態和結構化的設計
	
-------------------------------------------------------------------------

CHAPTER07.錯誤處理

1.開宗明義：
	程式可能會出錯，而我們有責任確保錯誤發生時，程式碼仍會繼續做他該做的事情，
	同時在轉寫錯誤處理時應注意整潔，避免錯誤處理模糊了原本程式碼的邏輯。

2.使用throw Exception取代回傳錯誤碼	
	使用回傳錯誤碼的方式會使程式碼變得雜亂，且呼叫者必須在呼叫結束以後立即檢查錯誤。
	使用拋出例外的方式可以將原先的程式碼跟錯誤處理兩者分開探討

3.try-catch-finally
	定義出一個scope，無論try發生甚麼意外，catch會讓程式維持在一致的狀態。

4.盡量使用不檢查型例外(Use Unchecked Exceptions)	
	當我們修改一個函式，使他執行到最後必定拋出一個檢查型例外時，
	這個函式的方法署名處(第一行)，必須加上throws子句進行該例外的宣告
	而且所有呼叫這個函式的上層的函式也必須增加上這個throws子句
	這樣由底層往高層推進，進行一連串的修改導致函式的密封性被破壞了(開放閉合準則)
	所有throws Exception路徑上的函式都必須往下瞭解低階例外的細節。
	例外處理的原意是為了允許程式在執行到較遠處才處理錯誤，但檢查型例外卻因此打破封閉性原則
	-->但在寫一些關鍵重要的東西時，檢查型例外還是滿管用的

5.處理錯誤時，須提供足夠的例外發生的相關內文資訊，給catch區塊足夠的錯誤訊息使例外能被記錄

6.定義例外類別時需要從呼叫者的角度進行定義，意即：他們是為何/如何被catch到的

7.<P.S.補充>包裹(wrapper)的優點
	(1)	可以通過包裹(wrapper)第三方的API達到減少對它的依賴性，
		將來就不用花太多力氣即可選擇更換另一個不同的函式庫，
		在測試自己的程式時，Wrapper也有助於模擬第三方的呼叫。
	(2)	不會被特定廠商的API設計給侷限，
		可以透過Wrapper去定義自己感覺合用的API
		EX.將多種例外狀況包裹後定義為單一的例外事件型態
		如:螢幕損壞、電源燒毀、風扇停止...-->多種例外皆定義在"設備問題"之中

8.當定義了錯誤處理但不想中止運算時
	(1)	可以選擇在catch中定義捕捉後要繼續執行的事情，但這容易搞亂程式的邏輯。
	(2)	Special Case Pattern(特殊情況模式)
			建立一個類別或設定一個物件讓他能夠替我們處理特殊情況，
			這麼做的同時，客戶端的程式碼就不必處理例外行為，
			因為例外行為被包裹在特殊情況物件當中。

9.不要讓方法回傳null
	可能會導致程式碼做了太多不必要的null檢查，如果想讓方法回傳null，
	不如試著讓他拋出一個例外，或回傳一個特殊情況物件來取代null

10.避免傳遞null到方法中，除非工作所使用的API預期你可能傳遞null
